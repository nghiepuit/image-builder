/*
Copyright (c) 2019 Daybrush
name: @scena/react-ruler
license: MIT
author: Daybrush
repository: https://github.com/daybrush/ruler/blob/master/packages/react-ruler
version: 0.2.1
*/
'use strict';

var React = require('react');
var frameworkUtils = require('framework-utils');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var Ruler =
/*#__PURE__*/
function (_super) {
  __extends(Ruler, _super);

  function Ruler() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      scrollPos: 0
    };
    _this.width = 0;
    _this.height = 0;
    return _this;
  }

  var __proto = Ruler.prototype;

  __proto.render = function () {
    return React.createElement("canvas", {
      ref: frameworkUtils.ref(this, "canvasElement"),
      style: this.props.style
    });
  };

  __proto.componentDidMount = function () {
    var canvas = this.canvasElement;
    var context = canvas.getContext("2d");
    this.canvasContext = context;
    this.resize();
  };

  __proto.componentDidUpdate = function () {
    this.resize();
  };

  __proto.scroll = function (scrollPos) {
    this.draw(scrollPos);
  };

  __proto.resize = function () {
    var canvas = this.canvasElement;
    var _a = this.props,
        width = _a.width,
        height = _a.height;
    this.width = width || canvas.offsetWidth;
    this.height = height || canvas.offsetHeight;
    canvas.width = this.width * 2;
    canvas.height = this.height * 2;
    this.draw();
  };

  __proto.draw = function (scrollPos) {
    if (scrollPos === void 0) {
      scrollPos = this.state.scrollPos;
    }

    var _a = this.props,
        unit = _a.unit,
        zoom = _a.zoom,
        type = _a.type,
        backgroundColor = _a.backgroundColor,
        lineColor = _a.lineColor,
        textColor = _a.textColor;
    var width = this.width;
    var height = this.height;
    var state = this.state;
    state.scrollPos = scrollPos;
    var context = this.canvasContext;
    var isHorizontal = type === "horizontal";
    context.rect(0, 0, width * 2, height * 2);
    context.fillStyle = backgroundColor;
    context.fill();
    context.save();
    context.scale(2, 2);
    context.strokeStyle = lineColor;
    context.lineWidth = 1;
    context.font = "10px sans-serif";
    context.fillStyle = textColor;
    context.translate(0.5, 0);
    context.beginPath();
    var size = isHorizontal ? width : height;
    var zoomUnit = zoom * unit;
    var minRange = Math.floor(scrollPos * zoom / zoomUnit);
    var maxRange = Math.ceil((scrollPos * zoom + size) / zoomUnit);
    var length = maxRange - minRange;

    for (var i = 0; i < length; ++i) {
      var startPos = ((i + minRange) * unit - scrollPos) * zoom;

      if (startPos >= -zoomUnit && startPos < size) {
        var startX = isHorizontal ? startPos + 3 : width - 18;
        var startY = isHorizontal ? height - 18 : startPos - 4;

        if (isHorizontal) {
          context.fillText("" + (i + minRange) * unit, startX, startY);
        } else {
          context.save();
          context.translate(startX, startY);
          context.rotate(-Math.PI / 2);
          context.fillText("" + (i + minRange) * unit, 0, 0);
          context.restore();
        }
      }

      for (var j = 0; j < 10; ++j) {
        var pos = startPos + j / 10 * zoomUnit;

        if (pos < 0 || pos >= size) {
          continue;
        }

        var lineSize = j === 0 ? isHorizontal ? height : width : j % 2 === 0 ? 10 : 7;
        var x1 = isHorizontal ? pos : width - lineSize;
        var x2 = isHorizontal ? pos : width;
        var y1 = isHorizontal ? height - lineSize : pos;
        var y2 = isHorizontal ? height : pos;
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
      }
    }

    context.stroke();
    context.restore();
  };

  Ruler.defaultProps = {
    type: "horizontal",
    zoom: 1,
    width: 0,
    height: 0,
    unit: 50,
    style: {
      width: "100%",
      height: "100%"
    },
    backgroundColor: "#333333",
    textColor: "#ffffff",
    lineColor: "#777777"
  };
  return Ruler;
}(React.PureComponent);

module.exports = Ruler;
//# sourceMappingURL=ruler.cjs.js.map
