{"ast":null,"code":"var _jsxFileName = \"/Users/nghiepphan/code/tham-khao/react-moveable-with-full-drag-select/src/ruler/Ruler.tsx\";\nimport * as React from \"react\";\nimport { ref } from \"framework-utils\";\nexport default class Ruler extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n    this.divisionsElement = void 0;\n    this.state = {\n      scrollPos: 0\n    };\n    this.canvasElement = void 0;\n    this.canvasContext = void 0;\n    this.width = 0;\n    this.height = 0;\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"canvas\", {\n      ref: ref(this, \"canvasElement\"),\n      style: this.props.style,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 27,\n        columnNumber: 12\n      }\n    });\n  }\n\n  componentDidMount() {\n    const canvas = this.canvasElement;\n    this.canvasContext = canvas.getContext(\"2d\");\n    this.resize();\n  }\n\n  componentDidUpdate() {\n    this.resize();\n  }\n\n  scroll(scrollPos) {\n    this.draw(scrollPos);\n  }\n\n  resize() {\n    const canvas = this.canvasElement;\n    const _this$props = this.props,\n          width = _this$props.width,\n          height = _this$props.height;\n    this.width = width || canvas.offsetWidth;\n    this.height = height || canvas.offsetHeight;\n    canvas.width = this.width * 2;\n    canvas.height = this.height * 2;\n    this.draw();\n  }\n\n  draw(scrollPos = this.state.scrollPos) {\n    const _ref = this.props,\n          unit = _ref.unit,\n          zoom = _ref.zoom,\n          type = _ref.type,\n          backgroundColor = _ref.backgroundColor,\n          lineColor = _ref.lineColor,\n          textColor = _ref.textColor;\n    const width = this.width;\n    const height = this.height;\n    const state = this.state;\n    state.scrollPos = scrollPos;\n    const context = this.canvasContext;\n    const isHorizontal = type === \"horizontal\";\n    context.rect(0, 0, width * 2, height * 2);\n    context.fillStyle = backgroundColor;\n    context.fill();\n    context.save();\n    context.scale(2, 2);\n    context.strokeStyle = lineColor;\n    context.lineWidth = 0.5;\n    context.font = \"9px sans-serif\";\n    context.fillStyle = textColor;\n    context.translate(0.5, 0);\n    context.beginPath();\n    const size = isHorizontal ? width : height;\n    const zoomUnit = zoom * unit;\n    const minRange = Math.floor(scrollPos * zoom / zoomUnit);\n    const maxRange = Math.ceil((scrollPos * zoom + size) / zoomUnit);\n    const length = maxRange - minRange;\n\n    for (let i = 0; i < length; ++i) {\n      const startPos = ((i + minRange) * unit - scrollPos) * zoom;\n\n      if (startPos >= -zoomUnit && startPos < size) {\n        const startX = isHorizontal ? startPos + 3 : width - 10;\n        const startY = isHorizontal ? height - 10 : startPos - 4;\n\n        if (isHorizontal) {\n          context.fillText(\"\".concat((i + minRange) * unit), startX, startY);\n        } else {\n          context.save();\n          context.translate(startX, startY);\n          context.rotate(-Math.PI / 2);\n          context.fillText(\"\".concat((i + minRange) * unit), 0, 0);\n          context.restore();\n        }\n      }\n\n      for (let j = 0; j < 10; ++j) {\n        const pos = startPos + j / 10 * zoomUnit;\n\n        if (pos < 0 || pos >= size) {\n          continue;\n        }\n\n        const lineSize = j === 0 ? isHorizontal ? height : width : j % 2 === 0 ? 10 : 7; // (j % 2 === 0 ? 7 : 7);\n\n        const x1 = isHorizontal ? pos : width - lineSize;\n        const x2 = isHorizontal ? pos : width;\n        const y1 = isHorizontal ? height - lineSize : pos;\n        const y2 = isHorizontal ? height : pos;\n        context.moveTo(x1, y1);\n        context.lineTo(x2, y2);\n      }\n    }\n\n    context.stroke();\n    context.restore();\n  }\n\n}\nRuler.defaultProps = {\n  type: \"horizontal\",\n  zoom: 1,\n  width: 0,\n  height: 0,\n  unit: 50,\n  style: {\n    width: \"100%\",\n    height: \"100%\"\n  },\n  backgroundColor: \"#161616\",\n  textColor: \"#969696\",\n  lineColor: \"#666666\"\n};","map":{"version":3,"sources":["/Users/nghiepphan/code/tham-khao/react-moveable-with-full-drag-select/src/ruler/Ruler.tsx"],"names":["React","ref","Ruler","PureComponent","divisionsElement","state","scrollPos","canvasElement","canvasContext","width","height","render","props","style","componentDidMount","canvas","getContext","resize","componentDidUpdate","scroll","draw","offsetWidth","offsetHeight","unit","zoom","type","backgroundColor","lineColor","textColor","context","isHorizontal","rect","fillStyle","fill","save","scale","strokeStyle","lineWidth","font","translate","beginPath","size","zoomUnit","minRange","Math","floor","maxRange","ceil","length","i","startPos","startX","startY","fillText","rotate","PI","restore","j","pos","lineSize","x1","x2","y1","y2","moveTo","lineTo","stroke","defaultProps"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { ref } from \"framework-utils\";\nimport { RulerInterface, RulerProps } from \"./types\";\n\nexport default class Ruler extends React.PureComponent<RulerProps>\n  implements RulerInterface {\n  public static defaultProps = {\n    type: \"horizontal\",\n    zoom: 1,\n    width: 0,\n    height: 0,\n    unit: 50,\n    style: { width: \"100%\", height: \"100%\" },\n    backgroundColor: \"#161616\",\n    textColor: \"#969696\",\n    lineColor: \"#666666\"\n  };\n  public divisionsElement!: HTMLElement;\n  public state = {\n    scrollPos: 0\n  };\n  public canvasElement!: HTMLCanvasElement;\n  private canvasContext!: CanvasRenderingContext2D;\n  private width = 0;\n  private height = 0;\n  public render() {\n    return <canvas ref={ref(this, \"canvasElement\")} style={this.props.style} />;\n  }\n  public componentDidMount() {\n    const canvas = this.canvasElement;\n    this.canvasContext = canvas.getContext(\"2d\")!;\n\n    this.resize();\n  }\n  public componentDidUpdate() {\n    this.resize();\n  }\n  public scroll(scrollPos: number) {\n    this.draw(scrollPos);\n  }\n  public resize() {\n    const canvas = this.canvasElement;\n    const { width, height } = this.props;\n\n    this.width = width || canvas.offsetWidth;\n    this.height = height || canvas.offsetHeight;\n    canvas.width = this.width * 2;\n    canvas.height = this.height * 2;\n    this.draw();\n  }\n  private draw(scrollPos: number = this.state.scrollPos) {\n    const { unit, zoom, type, backgroundColor, lineColor, textColor } = this\n      .props as Required<RulerProps>;\n    const width = this.width;\n    const height = this.height;\n    const state = this.state;\n    state.scrollPos = scrollPos;\n    const context = this.canvasContext;\n    const isHorizontal = type === \"horizontal\";\n\n    context.rect(0, 0, width * 2, height * 2);\n    context.fillStyle = backgroundColor;\n    context.fill();\n    context.save();\n    context.scale(2, 2);\n    context.strokeStyle = lineColor;\n    context.lineWidth = 0.5;\n    context.font = \"9px sans-serif\";\n    context.fillStyle = textColor;\n    context.translate(0.5, 0);\n    context.beginPath();\n\n    const size = isHorizontal ? width : height;\n    const zoomUnit = zoom * unit;\n    const minRange = Math.floor((scrollPos * zoom) / zoomUnit);\n    const maxRange = Math.ceil((scrollPos * zoom + size) / zoomUnit);\n    const length = maxRange - minRange;\n\n    for (let i = 0; i < length; ++i) {\n      const startPos = ((i + minRange) * unit - scrollPos) * zoom;\n\n      if (startPos >= -zoomUnit && startPos < size) {\n        const startX = isHorizontal ? startPos + 3 : width - 10;\n        const startY = isHorizontal ? height - 10 : startPos - 4;\n\n        if (isHorizontal) {\n          context.fillText(`${(i + minRange) * unit}`, startX, startY);\n        } else {\n          context.save();\n          context.translate(startX, startY);\n          context.rotate(-Math.PI / 2);\n          context.fillText(`${(i + minRange) * unit}`, 0, 0);\n          context.restore();\n        }\n      }\n\n      for (let j = 0; j < 10; ++j) {\n        const pos = startPos + (j / 10) * zoomUnit;\n\n        if (pos < 0 || pos >= size) {\n          continue;\n        }\n        const lineSize =\n          j === 0 ? (isHorizontal ? height : width) : j % 2 === 0 ? 10 : 7;\n\n        // (j % 2 === 0 ? 7 : 7);\n\n        const x1 = isHorizontal ? pos : width - lineSize;\n        const x2 = isHorizontal ? pos : width;\n        const y1 = isHorizontal ? height - lineSize : pos;\n        const y2 = isHorizontal ? height : pos;\n        context.moveTo(x1, y1);\n        context.lineTo(x2, y2);\n      }\n    }\n    context.stroke();\n    context.restore();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}