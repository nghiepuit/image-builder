{"ast":null,"code":"/*\nCopyright (c) 2016 Daybrush\nname: scenejs\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/scenejs.git\nversion: 1.1.5\n*/\nimport { isObject, isArray, toArray, isString, splitComma, splitSpace, RGBA, splitBracket, COLOR_MODELS, stringToRGBA, $, document, IS_WINDOW, ANIMATION, removeEvent, addEvent, OBJECT, ARRAY, PROPERTY, STRING, NUMBER, requestAnimationFrame, cancelAnimationFrame, splitUnit, camelize, isUndefined, TRANSFORM, FILTER, FUNCTION, dot as dot$1, isFunction, fromCSS, findIndex, find, KEYFRAMES, addClass, removeClass, hasClass, decamelize } from '@daybrush/utils';\nimport ListMap from 'list-map';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction cubic(y1, y2, t) {\n  var t2 = 1 - t; // Bezier Curve Formula\n\n  return t * t * t + 3 * t * t * t2 * y2 + 3 * t * t2 * t2 * y1;\n}\n\nfunction solveFromX(x1, x2, x) {\n  // x  0 ~ 1\n  // t 0 ~ 1\n  var t = x;\n  var solveX = x;\n  var dx = 1;\n\n  while (Math.abs(dx) > 1 / 1000) {\n    // 예상 t초에 의한 _x값\n    solveX = cubic(x1, x2, t);\n    dx = solveX - x; // 차이가 미세하면 그 값을 t로 지정\n\n    if (Math.abs(dx) < 1 / 1000) {\n      return t;\n    }\n\n    t -= dx / 2;\n  }\n\n  return t;\n}\n/**\n * @namespace easing\n */\n\n/**\n* Cubic Bezier curve.\n* @memberof easing\n* @func bezier\n* @param {number} [x1] - point1's x\n* @param {number} [y1] - point1's y\n* @param {number} [x2] - point2's x\n* @param {number} [y2] - point2's y\n* @return {function} the curve function\n* @example\nimport {bezier} from \"scenejs\";\nScene.bezier(0, 0, 1, 1) // LINEAR\nScene.bezier(0.25, 0.1, 0.25, 1) // EASE\n*/\n\n\nfunction bezier(x1, y1, x2, y2) {\n  /*\n        x = f(t)\n        calculate inverse function by x\n        t = f-1(x)\n    */\n  var func = function func(x) {\n    var t = solveFromX(x1, x2, Math.max(Math.min(1, x), 0));\n    return cubic(y1, y2, t);\n  };\n\n  func.easingName = \"cubic-bezier(\" + x1 + \",\" + y1 + \",\" + x2 + \",\" + y2 + \")\";\n  return func;\n}\n/**\n* Specifies a stepping function\n* @see {@link https://www.w3schools.com/cssref/css3_pr_animation-timing-function.asp|CSS3 Timing Function}\n* @memberof easing\n* @func steps\n* @param {number} count - point1's x\n* @param {\"start\" | \"end\"} postion - point1's y\n* @return {function} the curve function\n* @example\nimport {steps} from \"scenejs\";\nScene.steps(1, \"start\") // Scene.STEP_START\nScene.steps(1, \"end\") // Scene.STEP_END\n*/\n\n\nfunction steps(count, position) {\n  var func = function func(time) {\n    var level = 1 / count;\n\n    if (time >= 1) {\n      return 1;\n    }\n\n    return (position === \"start\" ? level : 0) + Math.floor(time / level) * level;\n  };\n\n  func.easingName = \"steps(\" + count + \", \" + position + \")\";\n  return func;\n}\n/**\n* Equivalent to steps(1, start)\n* @memberof easing\n* @name STEP_START\n* @static\n* @type {function}\n* @example\nimport {STEP_START} from \"scenejs\";\nScene.STEP_START // steps(1, start)\n*/\n\n\nvar STEP_START =\n/*#__PURE__#*/\nsteps(1, \"start\");\n/**\n* Equivalent to steps(1, end)\n* @memberof easing\n* @name STEP_END\n* @static\n* @type {function}\n* @example\nimport {STEP_END} from \"scenejs\";\nScene.STEP_END // steps(1, end)\n*/\n\nvar STEP_END =\n/*#__PURE__#*/\nsteps(1, \"end\");\n/**\n* Linear Speed (0, 0, 1, 1)\n* @memberof easing\n* @name LINEAR\n* @static\n* @type {function}\n* @example\nimport {LINEAR} from \"scenejs\";\nScene.LINEAR\n*/\n\nvar LINEAR =\n/*#__PURE__#*/\nbezier(0, 0, 1, 1);\n/**\n* Ease Speed (0.25, 0.1, 0.25, 1)\n* @memberof easing\n* @name EASE\n* @static\n* @type {function}\n* @example\nimport {EASE} from \"scenejs\";\nScene.EASE\n*/\n\nvar EASE =\n/*#__PURE__#*/\nbezier(0.25, 0.1, 0.25, 1);\n/**\n* Ease In Speed (0.42, 0, 1, 1)\n* @memberof easing\n* @name EASE_IN\n* @static\n* @type {function}\n* @example\nimport {EASE_IN} from \"scenejs\";\nScene.EASE_IN\n*/\n\nvar EASE_IN =\n/*#__PURE__#*/\nbezier(0.42, 0, 1, 1);\n/**\n* Ease Out Speed (0, 0, 0.58, 1)\n* @memberof easing\n* @name EASE_OUT\n* @static\n* @type {function}\n* @example\nimport {EASE_OUT} from \"scenejs\";\nScene.EASE_OUT\n*/\n\nvar EASE_OUT =\n/*#__PURE__#*/\nbezier(0, 0, 0.58, 1);\n/**\n* Ease In Out Speed (0.42, 0, 0.58, 1)\n* @memberof easing\n* @name EASE_IN_OUT\n* @static\n* @type {function}\n* @example\nimport {EASE_IN_OUT} from \"scenejs\";\nScene.EASE_IN_OUT\n*/\n\nvar EASE_IN_OUT =\n/*#__PURE__#*/\nbezier(0.42, 0, 0.58, 1);\n\nvar _a;\n\nvar PREFIX = \"__SCENEJS_\";\nvar DATA_SCENE_ID = \"data-scene-id\";\nvar TIMING_FUNCTION = \"animation-timing-function\";\nvar ROLES = {\n  transform: {},\n  filter: {},\n  attribute: {},\n  html: true\n};\nvar ALIAS = {\n  easing: [TIMING_FUNCTION]\n};\nvar FIXED = (_a = {}, _a[TIMING_FUNCTION] = true, _a.contents = true, _a.html = true, _a);\nvar MAXIMUM = 1000000;\nvar THRESHOLD = 0.000001;\nvar DURATION = \"duration\";\nvar FILL_MODE = \"fillMode\";\nvar DIRECTION = \"direction\";\nvar ITERATION_COUNT = \"iterationCount\";\nvar DELAY = \"delay\";\nvar EASING = \"easing\";\nvar PLAY_SPEED = \"playSpeed\";\nvar EASING_NAME = \"easingName\";\nvar ITERATION_TIME = \"iterationTime\";\nvar PAUSED = \"paused\";\nvar ENDED = \"ended\";\nvar TIMEUPDATE = \"timeupdate\";\nvar ANIMATE = \"animate\";\nvar PLAY = \"play\";\nvar RUNNING = \"running\";\nvar ITERATION = \"iteration\";\nvar START_ANIMATION = \"startAnimation\";\nvar PAUSE_ANIMATION = \"pauseAnimation\";\nvar ALTERNATE = \"alternate\";\nvar REVERSE = \"reverse\";\nvar ALTERNATE_REVERSE = \"alternate-reverse\";\nvar NORMAL = \"normal\";\nvar INFINITE = \"infinite\";\nvar PLAY_STATE = \"playState\";\nvar PLAY_CSS = \"playCSS\";\nvar PREV_TIME = \"prevTime\";\nvar TICK_TIME = \"tickTime\";\nvar CURRENT_TIME = \"currentTime\";\nvar SELECTOR = \"selector\";\nvar TRANSFORM_NAME = \"transform\";\nvar EASINGS = {\n  \"linear\": LINEAR,\n  \"ease\": EASE,\n  \"ease-in\": EASE_IN,\n  \"ease-out\": EASE_OUT,\n  \"ease-in-out\": EASE_IN_OUT,\n  \"step-start\": STEP_START,\n  \"step-end\": STEP_END\n};\n/**\n* option name list\n* @name Scene.OPTIONS\n* @memberof Scene\n* @static\n* @type {$ts:OptionType}\n* @example\n* Scene.OPTIONS // [\"duration\", \"fillMode\", \"direction\", \"iterationCount\", \"delay\", \"easing\", \"playSpeed\"]\n*/\n\nvar OPTIONS = [DURATION, FILL_MODE, DIRECTION, ITERATION_COUNT, DELAY, EASING, PLAY_SPEED];\n/**\n* Event name list\n* @name Scene.EVENTS\n* @memberof Scene\n* @static\n* @type {$ts:EventType}\n* @example\n* Scene.EVENTS // [\"paused\", \"ended\", \"timeupdate\", \"animate\", \"play\", \"iteration\"];\n*/\n\nvar EVENTS = [PAUSED, ENDED, TIMEUPDATE, ANIMATE, PLAY, ITERATION];\n/**\n* attach and trigger event handlers.\n*/\n\nvar EventTrigger = /*#__PURE__*/function () {\n  /**\n    * @example\n  const et = new Scene.EventTrigger();\n  const scene = new Scene();\n  scene.on(\"call\", e => {\n    console.log(e.param);\n  });\n  et.on(\"call\", e => {\n    console.log(e.param);\n  });\n  scene.trigger(\"call\", {param: 1});\n  et.trigger(\"call\", {param: 1});\n     */\n  function EventTrigger() {\n    this.events = {};\n  }\n\n  var __proto = EventTrigger.prototype;\n\n  __proto._on = function (name, callback, once) {\n    var _this = this;\n\n    var events = this.events;\n\n    if (isObject(name)) {\n      for (var n in name) {\n        this._on(n, name[n], once);\n      }\n\n      return;\n    }\n\n    if (!(name in events)) {\n      events[name] = [];\n    }\n\n    if (!callback) {\n      return;\n    }\n\n    if (isArray(callback)) {\n      callback.forEach(function (func) {\n        return _this._on(name, func, once);\n      });\n      return;\n    }\n\n    events[name].push(once ? function callback2() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      callback.apply(void 0, args);\n      this.off(name, callback2);\n    } : callback);\n  };\n  /**\n    * Attach an event handler function for one or more events to target\n    * @param - event's name\n    * @param - function to execute when the event is triggered.\n    * @return {EventTrigger} An Instance itself.\n    * @example\n  target.on(\"animate\", function() {\n    console.log(\"animate\");\n  });\n  target.trigger(\"animate\");\n   */\n\n\n  __proto.on = function (name, callback) {\n    this._on(name, callback);\n\n    return this;\n  };\n  /**\n    * Dettach an event handler function for one or more events to target\n    * @param - event's name\n    * @param -  function to execute when the event is triggered.\n    * @return {EventTrigger} An Instance itself.\n    * @example\n  const callback = function() {\n    console.log(\"animate\");\n  };\n  target.on(\"animate\", callback);\n  target.off(\"animate\", callback);\n  target.off(\"animate\");\n     */\n\n\n  __proto.off = function (name, callback) {\n    if (!name) {\n      this.events = {};\n    } else if (!callback) {\n      this.events[name] = [];\n    } else {\n      var callbacks = this.events[name];\n\n      if (!callbacks) {\n        return this;\n      }\n\n      var index = callbacks.indexOf(callback);\n\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n      }\n    }\n\n    return this;\n  };\n  /**\n    * execute event handler\n    * @param - event's name\n    * @param - event handler's additional parameter\n    * @return {EventTrigger} An Instance itself.\n    * @example\n  target.on(\"animate\", function(a1, a2) {\n    console.log(\"animate\", a1, a2);\n  });\n  target.trigger(\"animate\", [1, 2]); // log => \"animate\", 1, 2\n     */\n\n\n  __proto.trigger = function (name) {\n    var _this = this;\n\n    var data = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      data[_i - 1] = arguments[_i];\n    }\n\n    var events = this.events;\n\n    if (!(name in events)) {\n      return this;\n    }\n\n    var args = data || [];\n    !args[0] && (args[0] = {});\n    var event = events[name];\n    var target = args[0];\n    target.type = name;\n    target.currentTarget = this;\n    !target.target && (target.target = this);\n    toArray(events[name]).forEach(function (callback) {\n      callback.apply(_this, data);\n    });\n    return this;\n  };\n\n  __proto.once = function (name, callback) {\n    this._on(name, callback, true);\n\n    return this;\n  };\n\n  return EventTrigger;\n}();\n/**\n* Make string, array to PropertyObject for the dot product\n*/\n\n\nvar PropertyObject = /*#__PURE__*/function () {\n  /**\n    * @param - This value is in the array format.\n    * @param - options\n    * @example\n  var obj = new PropertyObject([100,100,100,0.5], {\n    \"separator\" : \",\",\n    \"prefix\" : \"rgba(\",\n    \"suffix\" : \")\"\n  });\n     */\n  function PropertyObject(value, options) {\n    this.prefix = \"\";\n    this.suffix = \"\";\n    this.model = \"\";\n    this.type = \"\";\n    this.separator = \",\";\n    options && this.setOptions(options);\n    this.value = isString(value) ? value.split(this.separator) : value;\n  }\n\n  var __proto = PropertyObject.prototype;\n\n  __proto.setOptions = function (newOptions) {\n    for (var name in newOptions) {\n      this[name] = newOptions[name];\n    }\n\n    return this;\n  };\n  /**\n    * the number of values.\n    * @example\n  const obj1 = new PropertyObject(\"1,2,3\", \",\");\n  console.log(obj1.length);\n  // 3\n     */\n\n\n  __proto.size = function () {\n    return this.value.length;\n  };\n  /**\n    * retrieve one of values at the index\n    * @param {Number} index - index\n    * @return {Object} one of values at the index\n    * @example\n  const obj1 = new PropertyObject(\"1,2,3\", \",\");\n  console.log(obj1.get(0));\n  // 1\n     */\n\n\n  __proto.get = function (index) {\n    return this.value[index];\n  };\n  /**\n    * Set the value at that index\n    * @param {Number} index - index\n    * @param {Object} value - text, a number, object to set\n    * @return {PropertyObject} An instance itself\n    * @example\n  const obj1 = new PropertyObject(\"1,2,3\", \",\");\n  obj1.set(0, 2);\n  console.log(obj1.toValue());\n  // 2,2,3\n     */\n\n\n  __proto.set = function (index, value) {\n    this.value[index] = value;\n    return this;\n  };\n  /**\n    * create a copy of an instance itself.\n    * @return {PropertyObject} clone\n    * @example\n  const obj1 = new PropertyObject(\"1,2,3\", \",\");\n  const obj2 = obj1.clone();\n     */\n\n\n  __proto.clone = function () {\n    var _a = this,\n        separator = _a.separator,\n        prefix = _a.prefix,\n        suffix = _a.suffix,\n        model = _a.model,\n        type = _a.type;\n\n    var arr = this.value.map(function (v) {\n      return v instanceof PropertyObject ? v.clone() : v;\n    });\n    return new PropertyObject(arr, {\n      separator: separator,\n      prefix: prefix,\n      suffix: suffix,\n      model: model,\n      type: type\n    });\n  };\n  /**\n    * Make Property Object to String\n    * @return {String} Make Property Object to String\n    * @example\n  //rgba(100, 100, 100, 0.5)\n  const obj4 = new PropertyObject([100,100,100,0.5], {\n    \"separator\" : \",\",\n    \"prefix\" : \"rgba(\",\n    \"suffix\" : \")\",\n  });\n  console.log(obj4.toValue());\n  // \"rgba(100,100,100,0.5)\"\n    */\n\n\n  __proto.toValue = function () {\n    return this.prefix + this.join() + this.suffix;\n  };\n  /**\n    * Make Property Object's array to String\n    * @return {String} Join the elements of an array into a string\n    * @example\n    //rgba(100, 100, 100, 0.5)\n    var obj4 = new PropertyObject([100,100,100,0.5], {\n        \"separator\" : \",\",\n        \"prefix\" : \"rgba(\",\n        \"suffix\" : \")\"\n    });\n    obj4.join();  // =>   \"100,100,100,0.5\"\n     */\n\n\n  __proto.join = function () {\n    return this.value.map(function (v) {\n      return v instanceof PropertyObject ? v.toValue() : v;\n    }).join(this.separator);\n  };\n  /**\n    * executes a provided function once per array element.\n    * @param {Function} callback - Function to execute for each element, taking three arguments\n    * @param {All} [callback.currentValue] The current element being processed in the array.\n    * @param {Number} [callback.index] The index of the current element being processed in the array.\n    * @param {Array} [callback.array] the array.\n    * @return {PropertyObject} An instance itself\n    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach|MDN Array.forEach()} reference to MDN document.\n    * @example\n  //rgba(100, 100, 100, 0.5)\n  var obj4 = new PropertyObject([100,100,100,0.5], {\n    \"separator\" : \",\",\n    \"prefix\" : \"rgba(\",\n    \"suffix\" : \")\"\n  });\n  obj4.forEach(t => {\n    console.log(t);\n  });  // =>   \"100,100,100,0.5\"\n    */\n\n\n  __proto.forEach = function (func) {\n    this.value.forEach(func);\n    return this;\n  };\n\n  return PropertyObject;\n}();\n/**\n* @namespace\n* @name Property\n*/\n\n\nfunction splitStyle(str) {\n  var properties = str.split(\";\");\n  var obj = {};\n  var length = properties.length;\n\n  for (var i = 0; i < length; ++i) {\n    var matches = /([^:]*):([\\S\\s]*)/g.exec(properties[i]);\n\n    if (!matches || matches.length < 3 || !matches[1]) {\n      --length;\n      continue;\n    }\n\n    obj[matches[1].trim()] = toPropertyObject(matches[2].trim());\n  }\n\n  return {\n    styles: obj,\n    length: length\n  };\n}\n/**\n* convert array to PropertyObject[type=color].\n* default model \"rgba\"\n* @memberof Property\n* @function arrayToColorObject\n* @param {Array|PropertyObject} value ex) [0, 0, 0, 1]\n* @return {PropertyObject} PropertyObject[type=color]\n* @example\narrayToColorObject([0, 0, 0])\n// => PropertyObject(type=\"color\", model=\"rgba\", value=[0, 0, 0, 1], separator=\",\")\n*/\n\n\nfunction arrayToColorObject(arr) {\n  var model = RGBA;\n\n  if (arr.length === 3) {\n    arr[3] = 1;\n  }\n\n  return new PropertyObject(arr, {\n    model: model,\n    separator: \",\",\n    type: \"color\",\n    prefix: model + \"(\",\n    suffix: \")\"\n  });\n}\n/**\n* convert text with parentheses to object.\n* @memberof Property\n* @function stringToBracketObject\n* @param {String} value ex) \"rgba(0,0,0,1)\"\n* @return {PropertyObject} PropertyObject\n* @example\nstringToBracketObject(\"abcde(0, 0, 0,1)\")\n// => PropertyObject(model=\"abcde\", value=[0, 0, 0,1], separator=\",\")\n*/\n\n\nfunction stringToBracketObject(text) {\n  // [prefix, value, other]\n  var _a = splitBracket(text),\n      model = _a.prefix,\n      value = _a.value,\n      afterModel = _a.suffix;\n\n  if (typeof value === \"undefined\") {\n    return text;\n  }\n\n  if (COLOR_MODELS.indexOf(model) !== -1) {\n    return arrayToColorObject(stringToRGBA(text));\n  } // divide comma(,)\n\n\n  var obj = toPropertyObject(value);\n  var arr = [value];\n  var separator = \",\";\n  var prefix = model + \"(\";\n  var suffix = \")\" + afterModel;\n\n  if (obj instanceof PropertyObject) {\n    separator = obj.separator;\n    arr = obj.value;\n    prefix += obj.prefix;\n    suffix = obj.suffix + suffix;\n  }\n\n  return new PropertyObject(arr, {\n    separator: separator,\n    model: model,\n    prefix: prefix,\n    suffix: suffix\n  });\n}\n\nfunction arrayToPropertyObject(arr, separator) {\n  return new PropertyObject(arr, {\n    type: \"array\",\n    separator: separator\n  });\n}\n/**\n* convert text with parentheses to PropertyObject[type=color].\n* If the values are not RGBA model, change them RGBA mdoel.\n* @memberof Property\n* @function stringToColorObject\n* @param {String|PropertyObject} value ex) \"rgba(0,0,0,1)\"\n* @return {PropertyObject} PropertyObject[type=color]\n* @example\nstringToColorObject(\"rgba(0, 0, 0,1)\")\n// => PropertyObject(type=\"color\", model=\"rgba\", value=[0, 0, 0,1], separator=\",\")\n*/\n\n\nfunction stringToColorObject(value) {\n  var result = stringToRGBA(value);\n  return result ? arrayToColorObject(result) : value;\n}\n\nfunction toPropertyObject(value) {\n  if (!isString(value)) {\n    if (isArray(value)) {\n      return arrayToPropertyObject(value, \",\");\n    }\n\n    return value;\n  }\n\n  var values = splitComma(value);\n\n  if (values.length > 1) {\n    return arrayToPropertyObject(values.map(function (v) {\n      return toPropertyObject(v);\n    }), \",\");\n  }\n\n  values = splitSpace(value);\n\n  if (values.length > 1) {\n    return arrayToPropertyObject(values.map(function (v) {\n      return toPropertyObject(v);\n    }), \" \");\n  }\n\n  values = /^(['\"])([^'\"]*)(['\"])$/g.exec(value);\n\n  if (values && values[1] === values[3]) {\n    // Quotes\n    return new PropertyObject([toPropertyObject(values[2])], {\n      prefix: values[1],\n      suffix: values[1]\n    });\n  } else if (value.indexOf(\"(\") !== -1) {\n    // color\n    return stringToBracketObject(value);\n  } else if (value.charAt(0) === \"#\") {\n    return stringToColorObject(value);\n  }\n\n  return value;\n}\n\nfunction toObject(object, result) {\n  if (result === void 0) {\n    result = {};\n  }\n\n  var model = object.model;\n\n  if (model) {\n    object.setOptions({\n      model: \"\",\n      suffix: \"\",\n      prefix: \"\"\n    });\n    var value = object.size() > 1 ? object : object.get(0);\n    result[model] = value;\n  } else {\n    object.forEach(function (obj) {\n      toObject(obj, result);\n    });\n  }\n\n  return result;\n}\n\nfunction isPropertyObject(value) {\n  return value instanceof PropertyObject;\n}\n\nfunction setAlias(name, alias) {\n  ALIAS[name] = alias;\n}\n\nfunction setRole(names, isProperty, isFixedProperty) {\n  var length = names.length;\n  var roles = ROLES;\n  var fixed = FIXED;\n\n  for (var i = 0; i < length - 1; ++i) {\n    !roles[names[i]] && (roles[names[i]] = {});\n    roles = roles[names[i]];\n\n    if (isFixedProperty) {\n      !fixed[names[i]] && (fixed[names[i]] = {});\n      fixed = fixed[names[i]];\n    }\n  }\n\n  isFixedProperty && (fixed[names[length - 1]] = true);\n  roles[names[length - 1]] = isProperty ? true : {};\n}\n\nfunction getType(value) {\n  var type = typeof value;\n\n  if (type === OBJECT) {\n    if (isArray(value)) {\n      return ARRAY;\n    } else if (isPropertyObject(value)) {\n      return PROPERTY;\n    }\n  } else if (type === STRING || type === NUMBER) {\n    return \"value\";\n  }\n\n  return type;\n}\n\nfunction isPureObject(obj) {\n  return isObject(obj) && obj.constructor === Object;\n}\n\nfunction getNames(names, stack) {\n  var arr = [];\n\n  if (isPureObject(names)) {\n    for (var name in names) {\n      stack.push(name);\n      arr = arr.concat(getNames(names[name], stack));\n      stack.pop();\n    }\n  } else {\n    arr.push(stack.slice());\n  }\n\n  return arr;\n}\n\nfunction updateFrame(names, properties) {\n  for (var name in properties) {\n    var value = properties[name];\n\n    if (!isPureObject(value)) {\n      names[name] = true;\n      continue;\n    }\n\n    if (!isObject(names[name])) {\n      names[name] = {};\n    }\n\n    updateFrame(names[name], properties[name]);\n  }\n\n  return names;\n}\n\nfunction toFixed(num) {\n  return Math.round(num * MAXIMUM) / MAXIMUM;\n}\n\nfunction getValueByNames(names, properties, length) {\n  if (length === void 0) {\n    length = names.length;\n  }\n\n  var value = properties;\n\n  for (var i = 0; i < length; ++i) {\n    if (!isObject(value)) {\n      return undefined;\n    }\n\n    value = value[names[i]];\n  }\n\n  return value;\n}\n\nfunction isInProperties(roles, args, isCheckTrue) {\n  var length = args.length;\n  var role = roles;\n\n  if (length === 0) {\n    return false;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    if (role === true) {\n      return false;\n    }\n\n    role = role[args[i]];\n\n    if (!role || !isCheckTrue && role === true) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isRole(args, isCheckTrue) {\n  return isInProperties(ROLES, args, isCheckTrue);\n}\n\nfunction isFixed(args) {\n  return isInProperties(FIXED, args, true);\n}\n\nfunction setPlayCSS(item, isActivate) {\n  item.state[PLAY_CSS] = isActivate;\n}\n\nfunction isPausedCSS(item) {\n  return item.state[PLAY_CSS] && item.isPaused();\n}\n\nfunction isEndedCSS(item) {\n  return !item.isEnded() && item.state[PLAY_CSS];\n}\n\nfunction exportCSS(id, css) {\n  var styleId = PREFIX + \"STYLE_\" + toId(id);\n  var styleElement = $(\"#\" + styleId);\n\n  if (styleElement) {\n    styleElement.innerText = css;\n  } else {\n    document.body.insertAdjacentHTML(\"beforeend\", \"<style id=\\\"\" + styleId + \"\\\">\" + css + \"</style>\");\n  }\n}\n\nfunction makeId(selector) {\n  for (;;) {\n    var id = \"\" + Math.floor(Math.random() * 10000000);\n\n    if (!IS_WINDOW || !selector) {\n      return id;\n    }\n\n    var checkElement = $(\"[data-scene-id=\\\"\" + id + \"\\\"]\");\n\n    if (!checkElement) {\n      return id;\n    }\n  }\n}\n\nfunction getRealId(item) {\n  return item.getId() || item.setId(makeId(false)).getId();\n}\n\nfunction toId(text) {\n  return (\"\" + text).match(/[0-9a-zA-Z]+/g).join(\"\");\n}\n\nfunction playCSS(item, isExportCSS, playClassName, properties) {\n  if (properties === void 0) {\n    properties = {};\n  }\n\n  if (!ANIMATION || item.getPlayState() === RUNNING) {\n    return;\n  }\n\n  var className = playClassName || START_ANIMATION;\n\n  if (isPausedCSS(item)) {\n    item.addPlayClass(true, className, properties);\n  } else {\n    if (item.isEnded()) {\n      item.setTime(0);\n    }\n\n    isExportCSS && item.exportCSS({\n      className: className\n    });\n    var el = item.addPlayClass(false, className, properties);\n\n    if (!el) {\n      return;\n    }\n\n    addAnimationEvent(item, el);\n    setPlayCSS(item, true);\n  }\n\n  item.setPlayState(RUNNING);\n}\n\nfunction addAnimationEvent(item, el) {\n  var state = item.state;\n  var duration = item.getDuration();\n  var isZeroDuration = !duration || !isFinite(duration);\n\n  var animationend = function animationend() {\n    setPlayCSS(item, false);\n    item.finish();\n  };\n\n  var animationstart = function animationstart() {\n    item.trigger(PLAY);\n  };\n\n  item.once(ENDED, function () {\n    removeEvent(el, \"animationcancel\", animationend);\n    removeEvent(el, \"animationend\", animationend);\n    removeEvent(el, \"animationiteration\", animationiteration);\n    removeEvent(el, \"animationstart\", animationstart);\n  });\n\n  var animationiteration = function animationiteration(_a) {\n    var elapsedTime = _a.elapsedTime;\n    var currentTime = elapsedTime;\n    var iterationCount = isZeroDuration ? 0 : currentTime / duration;\n    state[CURRENT_TIME] = currentTime;\n    item.setIteration(iterationCount);\n  };\n\n  addEvent(el, \"animationcancel\", animationend);\n  addEvent(el, \"animationend\", animationend);\n  addEvent(el, \"animationiteration\", animationiteration);\n  addEvent(el, \"animationstart\", animationstart);\n}\n\nfunction getEasing(curveArray) {\n  var easing;\n\n  if (isString(curveArray)) {\n    if (curveArray in EASINGS) {\n      easing = EASINGS[curveArray];\n    } else {\n      var obj = toPropertyObject(curveArray);\n\n      if (isString(obj)) {\n        return 0;\n      } else {\n        if (obj.model === \"cubic-bezier\") {\n          curveArray = obj.value.map(function (v) {\n            return parseFloat(v);\n          });\n          easing = bezier(curveArray[0], curveArray[1], curveArray[2], curveArray[3]);\n        } else if (obj.model === \"steps\") {\n          easing = steps(parseFloat(obj.value[0]), obj.value[1]);\n        } else {\n          return 0;\n        }\n      }\n    }\n  } else if (isArray(curveArray)) {\n    easing = bezier(curveArray[0], curveArray[1], curveArray[2], curveArray[3]);\n  } else {\n    easing = curveArray;\n  }\n\n  return easing;\n}\n\nfunction GetterSetter(getter, setter, parent) {\n  return function (constructor) {\n    var prototype = constructor.prototype;\n    getter.forEach(function (name) {\n      prototype[camelize(\"get \" + name)] = function () {\n        return this[parent][name];\n      };\n    });\n    setter.forEach(function (name) {\n      prototype[camelize(\"set \" + name)] = function (value) {\n        this[parent][name] = value;\n        return this;\n      };\n    });\n  };\n}\n\nfunction isDirectionReverse(iteration, iteraiontCount, direction) {\n  if (direction === REVERSE) {\n    return true;\n  } else if (iteraiontCount !== INFINITE && iteration === iteraiontCount && iteraiontCount % 1 === 0) {\n    return direction === (iteration % 2 >= 1 ? ALTERNATE_REVERSE : ALTERNATE);\n  }\n\n  return direction === (iteration % 2 >= 1 ? ALTERNATE : ALTERNATE_REVERSE);\n}\n/**\n* @typedef {Object} AnimatorState The Animator options. Properties used in css animation.\n* @property {number} [duration] The duration property defines how long an animation should take to complete one cycle.\n* @property {\"none\"|\"forwards\"|\"backwards\"|\"both\"} [fillMode] The fillMode property specifies a style for the element when the animation is not playing (before it starts, after it ends, or both).\n* @property {\"infinite\"|number} [iterationCount] The iterationCount property specifies the number of times an animation should be played.\n* @property {array|function} [easing] The easing(timing-function) specifies the speed curve of an animation.\n* @property {number} [delay] The delay property specifies a delay for the start of an animation.\n* @property {\"normal\"|\"reverse\"|\"alternate\"|\"alternate-reverse\"} [direction] The direction property defines whether an animation should be played forwards, backwards or in alternate cycles.\n*/\n\n\nvar setters = [\"id\", ITERATION_COUNT, DELAY, FILL_MODE, DIRECTION, PLAY_SPEED, DURATION, PLAY_SPEED, ITERATION_TIME, PLAY_STATE];\nvar getters = setters.concat([EASING, EASING_NAME]);\n/**\n* play video, animation, the others\n* @extends EventTrigger\n* @see {@link https://www.w3schools.com/css/css3_animations.asp|CSS3 Animation}\n*/\n\nvar Animator = /*#__PURE__*/function (_super) {\n  __extends(Animator, _super);\n  /**\n   * @param - animator's options\n   * @example\n  const animator = new Animator({\n    delay: 2,\n    diretion: \"alternate\",\n    duration: 2,\n    fillMode: \"forwards\",\n    iterationCount: 3,\n    easing: Scene.easing.EASE,\n  });\n   */\n\n\n  function Animator(options) {\n    var _this = _super.call(this) || this;\n\n    _this.timerId = 0;\n    _this.state = {\n      id: \"\",\n      easing: 0,\n      easingName: \"linear\",\n      iterationCount: 1,\n      delay: 0,\n      fillMode: \"forwards\",\n      direction: NORMAL,\n      playSpeed: 1,\n      currentTime: 0,\n      iterationTime: -1,\n      iteration: 0,\n      tickTime: 0,\n      prevTime: 0,\n      playState: PAUSED,\n      duration: 0\n    };\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n  /**\n    * set animator's easing.\n    * @param curverArray - The speed curve of an animation.\n    * @return {Animator} An instance itself.\n    * @example\n  animator.({\n    delay: 2,\n    diretion: \"alternate\",\n    duration: 2,\n    fillMode: \"forwards\",\n    iterationCount: 3,\n    easing: Scene.easing.EASE,\n  });\n    */\n\n\n  var __proto = Animator.prototype;\n\n  __proto.setEasing = function (curveArray) {\n    var easing = getEasing(curveArray);\n    var easingName = easing && easing[EASING_NAME] || \"linear\";\n    var state = this.state;\n    state[EASING] = easing;\n    state[EASING_NAME] = easingName;\n    return this;\n  };\n  /**\n    * set animator's options.\n    * @see {@link https://www.w3schools.com/css/css3_animations.asp|CSS3 Animation}\n    * @param - animator's options\n    * @return {Animator} An instance itself.\n    * @example\n  animator.({\n    delay: 2,\n    diretion: \"alternate\",\n    duration: 2,\n    fillMode: \"forwards\",\n    iterationCount: 3,\n    easing: Scene.eaasing.EASE,\n  });\n    */\n\n\n  __proto.setOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    for (var name in options) {\n      var value = options[name];\n\n      if (name === EASING) {\n        this.setEasing(value);\n        continue;\n      } else if (name === DURATION) {\n        value && this.setDuration(value);\n        continue;\n      }\n\n      if (OPTIONS.indexOf(name) > -1) {\n        this.state[name] = value;\n      }\n    }\n\n    return this;\n  };\n  /**\n    * Get the animator's total duration including delay\n    * @return {number} Total duration\n    * @example\n  animator.getTotalDuration();\n    */\n\n\n  __proto.getTotalDuration = function () {\n    return this.getActiveDuration(true);\n  };\n  /**\n    * Get the animator's total duration excluding delay\n    * @return {number} Total duration excluding delay\n    * @example\n  animator.getActiveDuration();\n    */\n\n\n  __proto.getActiveDuration = function (delay) {\n    var state = this.state;\n    var count = state[ITERATION_COUNT];\n\n    if (count === INFINITE) {\n      return Infinity;\n    }\n\n    return (delay ? state[DELAY] : 0) + this.getDuration() * count;\n  };\n  /**\n    * Check if the animator has reached the end.\n    * @return {boolean} ended\n    * @example\n  animator.isEnded(); // true or false\n    */\n\n\n  __proto.isEnded = function () {\n    if (this.state[TICK_TIME] === 0 && this.state[PLAY_STATE] === PAUSED) {\n      return true;\n    } else if (this.getTime() < this.getActiveDuration()) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n    *Check if the animator is paused:\n    * @return {boolean} paused\n    * @example\n  animator.isPaused(); // true or false\n    */\n\n\n  __proto.isPaused = function () {\n    return this.state[PLAY_STATE] === PAUSED;\n  };\n\n  __proto.start = function (delay) {\n    if (delay === void 0) {\n      delay = this.state[DELAY];\n    }\n\n    var state = this.state;\n    state[PLAY_STATE] = RUNNING;\n\n    if (state[TICK_TIME] >= delay) {\n      /**\n       * This event is fired when play animator.\n       * @event Animator#play\n       */\n      this.trigger(PLAY);\n      return true;\n    }\n\n    return false;\n  };\n  /**\n    * play animator\n    * @return {Animator} An instance itself.\n    */\n\n\n  __proto.play = function (toTime) {\n    var _this = this;\n\n    var state = this.state;\n    var delay = state[DELAY];\n    var currentTime = this.getTime();\n    state[PLAY_STATE] = RUNNING;\n\n    if (this.isEnded() && (currentTime === 0 || currentTime >= this.getActiveDuration())) {\n      this.setTime(-delay, true);\n    }\n\n    this.timerId = requestAnimationFrame(function (time) {\n      state[PREV_TIME] = time;\n\n      _this.tick(time, toTime);\n    });\n    this.start();\n    return this;\n  };\n  /**\n    * pause animator\n    * @return {Animator} An instance itself.\n    */\n\n\n  __proto.pause = function () {\n    var state = this.state;\n\n    if (state[PLAY_STATE] !== PAUSED) {\n      state[PLAY_STATE] = PAUSED;\n      /**\n       * This event is fired when animator is paused.\n       * @event Animator#paused\n       */\n\n      this.trigger(PAUSED);\n    }\n\n    cancelAnimationFrame(this.timerId);\n    return this;\n  };\n  /**\n     * end animator\n     * @return {Animator} An instance itself.\n    */\n\n\n  __proto.finish = function () {\n    this.setTime(0);\n    this.state[TICK_TIME] = 0;\n    this.end();\n    return this;\n  };\n  /**\n     * end animator\n     * @return {Animator} An instance itself.\n    */\n\n\n  __proto.end = function () {\n    this.pause();\n    /**\n         * This event is fired when animator is ended.\n         * @event Animator#ended\n         */\n\n    this.trigger(ENDED);\n    return this;\n  };\n  /**\n    * set currentTime\n    * @param {Number|String} time - currentTime\n    * @return {Animator} An instance itself.\n    * @example\n  animator.setTime(\"from\"); // 0\n  animator.setTime(\"to\"); // 100%\n  animator.setTime(\"50%\");\n  animator.setTime(10);\n  animator.getTime() // 10\n    */\n\n\n  __proto.setTime = function (time, isTick, isParent) {\n    var activeDuration = this.getActiveDuration();\n    var state = this.state;\n    var prevTime = state[TICK_TIME];\n    var delay = state[DELAY];\n    var currentTime = isTick ? time : this.getUnitTime(time);\n    state[TICK_TIME] = delay + currentTime;\n\n    if (currentTime < 0) {\n      currentTime = 0;\n    } else if (currentTime > activeDuration) {\n      currentTime = activeDuration;\n    }\n\n    state[CURRENT_TIME] = currentTime;\n    this.calculate();\n\n    if (isTick && !isParent) {\n      var tickTime = state[TICK_TIME];\n\n      if (prevTime < delay && time >= 0) {\n        this.start(0);\n      }\n\n      if (tickTime < prevTime || this.isEnded()) {\n        this.end();\n        return;\n      }\n    }\n\n    if (this.isDelay()) {\n      return this;\n    }\n    /**\n         * This event is fired when the animator updates the time.\n         * @event Animator#timeupdate\n         * @param {Object} param The object of data to be sent to an event.\n         * @param {Number} param.currentTime The total time that the animator is running.\n         * @param {Number} param.time The iteration time during duration that the animator is running.\n         * @param {Number} param.iterationCount The iteration count that the animator is running.\n         */\n\n\n    this.trigger(TIMEUPDATE, {\n      currentTime: currentTime,\n      time: this.getIterationTime(),\n      iterationCount: state[ITERATION]\n    });\n    return this;\n  };\n  /**\n    * Get the animator's current time\n    * @return {number} current time\n    * @example\n  animator.getTime();\n    */\n\n\n  __proto.getTime = function () {\n    return this.state[CURRENT_TIME];\n  };\n\n  __proto.getUnitTime = function (time) {\n    if (isString(time)) {\n      var duration = this.getDuration() || 100;\n\n      if (time === \"from\") {\n        return 0;\n      } else if (time === \"to\") {\n        return duration;\n      }\n\n      var _a = splitUnit(time),\n          unit = _a.unit,\n          value = _a.value;\n\n      if (unit === \"%\") {\n        !this.getDuration() && this.setDuration(duration);\n        return toFixed(parseFloat(time) / 100 * duration);\n      } else if (unit === \">\") {\n        return value + THRESHOLD;\n      } else {\n        return value;\n      }\n    } else {\n      return toFixed(time);\n    }\n  };\n  /**\n     * Check if the current state of animator is delayed.\n     * @return {boolean} check delay state\n     */\n\n\n  __proto.isDelay = function () {\n    var state = this.state;\n    var delay = state[DELAY];\n    var tickTime = state[TICK_TIME];\n    return delay > 0 && tickTime < delay;\n  };\n\n  __proto.setIteration = function (iterationCount) {\n    var state = this.state;\n    var passIterationCount = Math.floor(iterationCount);\n    var maxIterationCount = state[ITERATION_COUNT] === INFINITE ? Infinity : state[ITERATION_COUNT];\n\n    if (state[ITERATION] < passIterationCount && passIterationCount < maxIterationCount) {\n      /**\n            * The event is fired when an iteration of an animation ends.\n            * @event Animator#iteration\n            * @param {Object} param The object of data to be sent to an event.\n            * @param {Number} param.currentTime The total time that the animator is running.\n            * @param {Number} param.iterationCount The iteration count that the animator is running.\n            */\n      this.trigger(\"iteration\", {\n        currentTime: state[CURRENT_TIME],\n        iterationCount: passIterationCount\n      });\n    }\n\n    state[ITERATION] = iterationCount;\n    return this;\n  };\n\n  __proto.calculate = function () {\n    var state = this.state;\n    var iterationCount = state[ITERATION_COUNT];\n    var fillMode = state[FILL_MODE];\n    var direction = state[DIRECTION];\n    var duration = this.getDuration();\n    var time = this.getTime();\n    var iteration = duration === 0 ? 0 : time / duration;\n    var currentIterationTime = duration ? time % duration : 0;\n\n    if (!duration) {\n      this.setIterationTime(0);\n      return this;\n    }\n\n    this.setIteration(iteration); // direction : normal, reverse, alternate, alternate-reverse\n    // fillMode : forwards, backwards, both, none\n\n    var isReverse = isDirectionReverse(iteration, iterationCount, direction);\n    var isFiniteDuration = isFinite(duration);\n\n    if (isFiniteDuration && isReverse) {\n      currentIterationTime = duration - currentIterationTime;\n    }\n\n    if (isFiniteDuration && iterationCount !== INFINITE) {\n      var isForwards = fillMode === \"both\" || fillMode === \"forwards\"; // fill forwards\n\n      if (iteration >= iterationCount) {\n        currentIterationTime = duration * (isForwards ? iterationCount % 1 || 1 : 0);\n        isReverse && (currentIterationTime = duration - currentIterationTime);\n      }\n    }\n\n    this.setIterationTime(currentIterationTime);\n    return this;\n  };\n\n  __proto.tick = function (now, to) {\n    var _this = this;\n\n    if (this.isPaused()) {\n      return;\n    }\n\n    var state = this.state;\n    var playSpeed = state[PLAY_SPEED];\n    var prevTime = state[PREV_TIME];\n    var delay = state[DELAY];\n    var tickTime = state[TICK_TIME];\n    var currentTime = tickTime + Math.min(1000, now - prevTime) / 1000 * playSpeed;\n    state[PREV_TIME] = now;\n    this.setTime(currentTime - delay, true);\n\n    if (to && to * 1000 < now) {\n      this.pause();\n    }\n\n    if (state[PLAY_STATE] === PAUSED) {\n      return;\n    }\n\n    this.timerId = requestAnimationFrame(function (time) {\n      _this.tick(time, to);\n    });\n  };\n\n  Animator = __decorate([GetterSetter(getters, setters, \"state\")], Animator);\n  return Animator;\n}(EventTrigger);\n\nfunction toInnerProperties(obj) {\n  if (!obj) {\n    return \"\";\n  }\n\n  var arrObj = [];\n\n  for (var name in obj) {\n    arrObj.push(name.replace(/\\d$/g, \"\") + \"(\" + obj[name] + \")\");\n  }\n\n  return arrObj.join(\" \");\n}\n/* eslint-disable */\n\n\nfunction clone(target, toValue) {\n  if (toValue === void 0) {\n    toValue = false;\n  }\n\n  return merge({}, target, toValue);\n}\n\nfunction merge(to, from, toValue) {\n  if (toValue === void 0) {\n    toValue = false;\n  }\n\n  for (var name in from) {\n    var value = from[name];\n    var type = getType(value);\n\n    if (type === PROPERTY) {\n      to[name] = toValue ? value.toValue() : value.clone();\n    } else if (type === FUNCTION) {\n      to[name] = toValue ? getValue([name], value) : value;\n    } else if (type === ARRAY) {\n      to[name] = value.slice();\n    } else if (type === OBJECT) {\n      if (isObject(to[name]) && !isPropertyObject(to[name])) {\n        merge(to[name], value, toValue);\n      } else {\n        to[name] = clone(value, toValue);\n      }\n    } else {\n      to[name] = from[name];\n    }\n  }\n\n  return to;\n}\n/* eslint-enable */\n\n\nfunction getPropertyName(args) {\n  return args[0] in ALIAS ? ALIAS[args[0]] : args;\n}\n\nfunction getValue(names, value) {\n  var type = getType(value);\n\n  if (type === PROPERTY) {\n    return value.toValue();\n  } else if (type === FUNCTION) {\n    if (names[0] !== TIMING_FUNCTION) {\n      return getValue(names, value());\n    }\n  } else if (type === OBJECT) {\n    return clone(value, true);\n  }\n\n  return value;\n}\n/**\n* Animation's Frame\n*/\n\n\nvar Frame = /*#__PURE__*/function () {\n  /**\n   * @param - properties\n   * @example\n  const frame = new Scene.Frame({\n    display: \"none\"\n    transform: {\n        translate: \"50px\",\n        scale: \"5, 5\",\n    }\n  });\n   */\n  function Frame(properties) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    this.properties = {};\n    this.set(properties);\n  }\n  /**\n    * get property value\n    * @param {...Number|String|PropertyObject} args - property name or value\n    * @example\n    frame.get(\"display\") // => \"none\", \"block\", ....\n    frame.get(\"transform\", \"translate\") // => \"10px,10px\"\n    */\n\n\n  var __proto = Frame.prototype;\n\n  __proto.get = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var value = this.raw.apply(this, args);\n    return getValue(getPropertyName(args), value);\n  };\n\n  __proto.raw = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return getValueByNames(getPropertyName(args), this.properties);\n  };\n  /**\n    * remove property value\n    * @param {...String} args - property name\n    * @return {Frame} An instance itself\n    * @example\n    frame.remove(\"display\")\n    */\n\n\n  __proto.remove = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var params = getPropertyName(args);\n    var length = params.length;\n\n    if (!length) {\n      return this;\n    }\n\n    var value = getValueByNames(params, this.properties, length - 1);\n\n    if (isObject(value)) {\n      delete value[params[length - 1]];\n    }\n\n    return this;\n  };\n  /**\n    * set property\n    * @param {...Number|String|PropertyObject} args - property names or values\n    * @return {Frame} An instance itself\n    * @example\n  // one parameter\n  frame.set({\n    display: \"none\",\n    transform: {\n        translate: \"10px, 10px\",\n        scale: \"1\",\n    },\n    filter: {\n        brightness: \"50%\",\n        grayscale: \"100%\"\n    }\n  });\n  // two parameters\n  frame.set(\"transform\", {\n    translate: \"10px, 10px\",\n    scale: \"1\",\n  });\n  // three parameters\n  frame.set(\"transform\", \"translate\", \"50px\");\n  */\n\n\n  __proto.set = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var self = this;\n    var length = args.length;\n    var params = args.slice(0, -1);\n    var value = args[length - 1];\n    var firstParam = params[0];\n\n    if (length === 1 && value instanceof Frame) {\n      self.merge(value);\n    } else if (firstParam in ALIAS) {\n      self._set(ALIAS[firstParam], value);\n    } else if (length === 2 && isArray(firstParam)) {\n      self._set(firstParam, value);\n    } else if (isPropertyObject(value)) {\n      if (isRole(params)) {\n        self.set.apply(self, params.concat([toObject(value)]));\n      } else {\n        self._set(params, value);\n      }\n    } else if (isArray(value)) {\n      self._set(params, value);\n    } else if (isObject(value)) {\n      if (!self.has.apply(self, params) && isRole(params)) {\n        self._set(params, {});\n      }\n\n      for (var name in value) {\n        self.set.apply(self, params.concat([name, value[name]]));\n      }\n    } else if (isString(value)) {\n      if (isRole(params, true)) {\n        if (isFixed(params) || !isRole(params)) {\n          this._set(params, value);\n        } else {\n          var obj = toPropertyObject(value);\n\n          if (isObject(obj)) {\n            self.set.apply(self, params.concat([obj]));\n          }\n        }\n\n        return this;\n      } else {\n        var _a = splitStyle(value),\n            styles = _a.styles,\n            stylesLength = _a.length;\n\n        for (var name in styles) {\n          self.set.apply(self, params.concat([name, styles[name]]));\n        }\n\n        if (stylesLength) {\n          return this;\n        }\n      }\n\n      self._set(params, value);\n    } else {\n      self._set(params, value);\n    }\n\n    return self;\n  };\n  /**\n    * Gets the names of properties.\n    * @return the names of properties.\n    * @example\n  // one parameter\n  frame.set({\n    display: \"none\",\n    transform: {\n        translate: \"10px, 10px\",\n        scale: \"1\",\n    },\n  });\n  // [[\"display\"], [\"transform\", \"translate\"], [\"transform\", \"scale\"]]\n  console.log(frame.getNames());\n  */\n\n\n  __proto.getNames = function () {\n    return getNames(this.properties, []);\n  };\n  /**\n    * check that has property.\n    * @param {...String} args - property name\n    * @example\n    frame.has(\"property\", \"display\") // => true or false\n    */\n\n\n  __proto.has = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var params = getPropertyName(args);\n    var length = params.length;\n\n    if (!length) {\n      return false;\n    }\n\n    return !isUndefined(getValueByNames(params, this.properties, length));\n  };\n  /**\n    * clone frame.\n    * @return {Frame} An instance of clone\n    * @example\n    frame.clone();\n    */\n\n\n  __proto.clone = function () {\n    var frame = new Frame();\n    return frame.merge(this);\n  };\n  /**\n    * merge one frame to other frame.\n    * @param - target frame.\n    * @return {Frame} An instance itself\n    * @example\n    frame.merge(frame2);\n    */\n\n\n  __proto.merge = function (frame) {\n    var properties = this.properties;\n    var frameProperties = frame.properties;\n\n    if (frameProperties) {\n      merge(properties, frameProperties);\n    }\n\n    return this;\n  };\n  /**\n    * Specifies an css object that coverted the frame.\n    * @return {object} cssObject\n    */\n\n\n  __proto.toCSSObject = function () {\n    var properties = this.get();\n    var cssObject = {};\n\n    for (var name in properties) {\n      if (isRole([name], true)) {\n        continue;\n      }\n\n      var value = properties[name];\n\n      if (name === TIMING_FUNCTION) {\n        cssObject[TIMING_FUNCTION.replace(\"animation\", ANIMATION)] = (isString(value) ? value : value[EASING_NAME]) || \"initial\";\n      } else {\n        cssObject[name] = value;\n      }\n    }\n\n    var transform = toInnerProperties(properties[TRANSFORM_NAME]);\n    var filter = toInnerProperties(properties.filter);\n    TRANSFORM && transform && (cssObject[TRANSFORM] = transform);\n    FILTER && filter && (cssObject[FILTER] = filter);\n    return cssObject;\n  };\n  /**\n    * Specifies an css text that coverted the frame.\n    * @return {string} cssText\n    */\n\n\n  __proto.toCSS = function () {\n    var cssObject = this.toCSSObject();\n    var cssArray = [];\n\n    for (var name in cssObject) {\n      cssArray.push(name + \":\" + cssObject[name] + \";\");\n    }\n\n    return cssArray.join(\"\");\n  };\n\n  __proto._set = function (args, value) {\n    var properties = this.properties;\n    var length = args.length;\n\n    for (var i = 0; i < length - 1; ++i) {\n      var name = args[i];\n      !(name in properties) && (properties[name] = {});\n      properties = properties[name];\n    }\n\n    if (!length) {\n      return;\n    }\n\n    if (args.length === 1 && args[0] === TIMING_FUNCTION) {\n      properties[TIMING_FUNCTION] = getEasing(value);\n    } else {\n      properties[args[length - 1]] = isString(value) && !isFixed(args) ? toPropertyObject(value) : value;\n    }\n  };\n\n  return Frame;\n}();\n\nfunction dotArray(a1, a2, b1, b2) {\n  var length = a2.length;\n  return a1.map(function (v1, i) {\n    if (i >= length) {\n      return v1;\n    } else {\n      return dot(v1, a2[i], b1, b2);\n    }\n  });\n}\n\nfunction dotColor(color1, color2, b1, b2) {\n  // convert array to PropertyObject(type=color)\n  var value1 = color1.value;\n  var value2 = color2.value; // If the model name is not same, the inner product is impossible.\n\n  var model1 = color1.model;\n  var model2 = color2.model;\n\n  if (model1 !== model2) {\n    // It is recognized as a string.\n    return dot(color1.toValue(), color2.toValue(), b1, b2);\n  }\n\n  if (value1.length === 3) {\n    value1[3] = 1;\n  }\n\n  if (value2.length === 3) {\n    value2[3] = 1;\n  }\n\n  var v = dotArray(value1, value2, b1, b2);\n  var colorModel = model1;\n\n  for (var i = 0; i < 3; ++i) {\n    v[i] = parseInt(v[i], 10);\n  }\n\n  var object = new PropertyObject(v, {\n    type: \"color\",\n    model: colorModel,\n    prefix: colorModel + \"(\",\n    suffix: \")\"\n  });\n  return object;\n}\n\nfunction dotObject(a1, a2, b1, b2) {\n  var a1Type = a1.type;\n\n  if (a1Type === \"color\") {\n    return dotColor(a1, a2, b1, b2);\n  }\n\n  var value1 = a1.value;\n  var value2 = a2.value;\n  var arr = dotArray(value1, value2, b1, b2);\n  return new PropertyObject(arr, {\n    type: a1Type,\n    separator: a1.separator || a2.separator,\n    prefix: a1.prefix || a2.prefix,\n    suffix: a1.suffix || a2.suffix,\n    model: a1.model || a2.model\n  });\n}\n/**\n* The dot product of a1 and a2 for the b1 and b2.\n* @memberof Dot\n* @function dot\n* @param {String|Number|PropertyObject} a1 value1\n* @param {String|Number|PropertyObject} a2 value2\n* @param {Number} b1 b1 ratio\n* @param {Number} b2 b2 ratio\n* @return {String} Not Array, Not Separator, Only Number & Unit\n* @return {PropertyObject} Array with Separator.\n* @example\ndot(1, 3, 0.3, 0.7);\n// => 1.6\n*/\n\n\nfunction dot(a1, a2, b1, b2) {\n  if (b2 === 0) {\n    return a2;\n  } else if (b1 === 0 || b1 + b2 === 0) {\n    // prevent division by zero.\n    return a1;\n  } // dot Object\n\n\n  var type1 = getType(a1);\n  var type2 = getType(a2);\n  var isFunction1 = type1 === FUNCTION;\n  var isFunction2 = type2 === FUNCTION;\n\n  if (isFunction1 || isFunction2) {\n    return function () {\n      return dot(isFunction1 ? toPropertyObject(a1()) : a1, isFunction2 ? toPropertyObject(a2()) : a2, b1, b2);\n    };\n  } else if (type1 === type2) {\n    if (type1 === PROPERTY) {\n      return dotObject(a1, a2, b1, b2);\n    } else if (type1 === ARRAY) {\n      return dotArray(a1, a2, b1, b2);\n    } else if (type1 !== \"value\") {\n      return a1;\n    }\n  } else {\n    return a1;\n  }\n\n  var v1 = splitUnit(\"\" + a1);\n  var v2 = splitUnit(\"\" + a2);\n  var v; // 숫자가 아닐경우 첫번째 값을 반환 b2가 0일경우 두번째 값을 반환\n\n  if (isNaN(v1.value) || isNaN(v2.value)) {\n    return a1;\n  } else {\n    v = dot$1(v1.value, v2.value, b1, b2);\n  }\n\n  var prefix = v1.prefix || v2.prefix;\n  var unit = v1.unit || v2.unit;\n\n  if (!prefix && !unit) {\n    return v;\n  }\n\n  return prefix + v + unit;\n}\n\nfunction dotValue(time, prevTime, nextTime, prevValue, nextValue, easing) {\n  if (time === prevTime) {\n    return prevValue;\n  } else if (time === nextTime) {\n    return nextValue;\n  } else if (!easing) {\n    return dot(prevValue, nextValue, time - prevTime, nextTime - time);\n  }\n\n  var ratio = easing((time - prevTime) / (nextTime - prevTime));\n  var value = dot(prevValue, nextValue, ratio, 1 - ratio);\n  return value;\n}\n\nfunction getNearTimeIndex(times, time) {\n  var length = times.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (times[i] === time) {\n      return [i, i];\n    } else if (times[i] > time) {\n      return [i > 0 ? i - 1 : 0, i];\n    }\n  }\n\n  return [length - 1, length - 1];\n}\n\nfunction makeAnimationProperties(properties) {\n  var cssArray = [];\n\n  for (var name in properties) {\n    cssArray.push(ANIMATION + \"-\" + decamelize(name) + \":\" + properties[name] + \";\");\n  }\n\n  return cssArray.join(\"\");\n}\n\nfunction addTime(times, time) {\n  var length = times.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (time < times[i]) {\n      times.splice(i, 0, time);\n      return;\n    }\n  }\n\n  times[length] = time;\n}\n\nfunction addEntry(entries, time, keytime) {\n  var prevEntry = entries[entries.length - 1];\n  (!prevEntry || prevEntry[0] !== time || prevEntry[1] !== keytime) && entries.push([toFixed(time), toFixed(keytime)]);\n}\n\nfunction getEntries(times, states) {\n  var entries = times.map(function (time) {\n    return [time, time];\n  });\n  var nextEntries = [];\n  states.forEach(function (state) {\n    var iterationCount = state[ITERATION_COUNT];\n    var delay = state[DELAY];\n    var playSpeed = state[PLAY_SPEED];\n    var direction = state[DIRECTION];\n    var intCount = Math.ceil(iterationCount);\n    var currentDuration = entries[entries.length - 1][0];\n    var length = entries.length;\n    var lastTime = currentDuration * iterationCount;\n\n    for (var i = 0; i < intCount; ++i) {\n      var isReverse = direction === REVERSE || direction === ALTERNATE && i % 2 || direction === ALTERNATE_REVERSE && !(i % 2);\n\n      for (var j = 0; j < length; ++j) {\n        var entry = entries[isReverse ? length - j - 1 : j];\n        var time = entry[1];\n        var currentTime = currentDuration * i + (isReverse ? currentDuration - entry[0] : entry[0]);\n        var prevEntry = entries[isReverse ? length - j : j - 1];\n\n        if (currentTime > lastTime) {\n          if (j !== 0) {\n            var prevTime = currentDuration * i + (isReverse ? currentDuration - prevEntry[0] : prevEntry[0]);\n            var divideTime = dot$1(prevEntry[1], time, lastTime - prevTime, currentTime - lastTime);\n            addEntry(nextEntries, (delay + currentDuration * iterationCount) / playSpeed, divideTime);\n          }\n\n          break;\n        } else if (currentTime === lastTime && nextEntries.length && nextEntries[nextEntries.length - 1][0] === lastTime + delay) {\n          break;\n        }\n\n        addEntry(nextEntries, (delay + currentTime) / playSpeed, time);\n      }\n    } // delay time\n\n\n    delay && nextEntries.unshift([0, nextEntries[0][1]]);\n    entries = nextEntries;\n    nextEntries = [];\n  });\n  return entries;\n}\n/**\n* manage Frame Keyframes and play keyframes.\n* @extends Animator\n* @example\nconst item = new SceneItem({\n    0: {\n        display: \"none\",\n    },\n    1: {\n        display: \"block\",\n        opacity: 0,\n    },\n    2: {\n        opacity: 1,\n    }\n});\n*/\n\n\nvar SceneItem = /*#__PURE__*/function (_super) {\n  __extends(SceneItem, _super);\n  /**\n    * @param - properties\n    * @param - options\n    * @example\n    const item = new SceneItem({\n        0: {\n            display: \"none\",\n        },\n        1: {\n            display: \"block\",\n            opacity: 0,\n        },\n        2: {\n            opacity: 1,\n        }\n    });\n     */\n\n\n  function SceneItem(properties, options) {\n    var _this = _super.call(this) || this;\n\n    _this.times = [];\n    _this.items = {};\n    _this.names = {};\n    _this.elements = [];\n    _this.needUpdate = true;\n\n    _this.load(properties, options);\n\n    return _this;\n  }\n\n  var __proto = SceneItem.prototype;\n\n  __proto.getDuration = function () {\n    var times = this.times;\n    var length = times.length;\n    return (length === 0 ? 0 : times[length - 1]) || this.state[DURATION];\n  };\n  /**\n    * get size of list\n    * @return {Number} length of list\n    */\n\n\n  __proto.size = function () {\n    return this.times.length;\n  };\n\n  __proto.setDuration = function (duration) {\n    if (!duration) {\n      return this;\n    }\n\n    var originalDuration = this.getDuration();\n\n    if (originalDuration > 0) {\n      var ratio_1 = duration / originalDuration;\n\n      var _a = this,\n          times = _a.times,\n          items_1 = _a.items;\n\n      var obj_1 = {};\n      this.times = times.map(function (time) {\n        var time2 = toFixed(time * ratio_1);\n        obj_1[time2] = items_1[time];\n        return time2;\n      });\n      this.items = obj_1;\n    } else {\n      this.newFrame(duration);\n    }\n\n    return this;\n  };\n\n  __proto.setId = function (id) {\n    var state = this.state;\n    state.id = id || makeId(!!length);\n    var elements = this.elements;\n\n    if (elements.length && !state[SELECTOR]) {\n      var sceneId_1 = toId(this.getId());\n      state[SELECTOR] = \"[\" + DATA_SCENE_ID + \"=\\\"\" + sceneId_1 + \"\\\"]\";\n      elements.forEach(function (element) {\n        element.setAttribute(DATA_SCENE_ID, sceneId_1);\n      });\n    }\n\n    return this;\n  };\n  /**\n    * Set properties to the sceneItem at that time\n    * @param {Number} time - time\n    * @param {...String|Object} [properties] - property names or values\n    * @return {SceneItem} An instance itself\n    * @example\n  item.set(0, \"a\", \"b\") // item.getFrame(0).set(\"a\", \"b\")\n  console.log(item.get(0, \"a\")); // \"b\"\n    */\n\n\n  __proto.set = function (time) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (time instanceof SceneItem) {\n      return this.set(0, time);\n    } else if (isArray(time)) {\n      var length = time.length;\n\n      for (var i = 0; i < length; ++i) {\n        var t = length === 1 ? 0 : this.getUnitTime(i / (length - 1) * 100 + \"%\");\n        this.set(t, time[i]);\n      }\n    } else if (isObject(time)) {\n      var _loop_1 = function _loop_1(t) {\n        var value = time[t];\n        splitComma(t).forEach(function (eachTime) {\n          var realTime = _this.getUnitTime(eachTime);\n\n          if (isNaN(realTime)) {\n            getNames(value, [eachTime]).forEach(function (names) {\n              var _a;\n\n              var innerValue = getValueByNames(names.slice(1), value);\n              var arr = isArray(innerValue) ? innerValue : [getValueByNames(names, _this.target), innerValue];\n              var length = arr.length;\n\n              for (var i = 0; i < length; ++i) {\n                (_a = _this.newFrame(i / (length - 1) * 100 + \"%\")).set.apply(_a, names.concat([arr[i]]));\n              }\n            });\n          } else {\n            _this.set(realTime, value);\n          }\n        });\n      };\n\n      for (var t in time) {\n        _loop_1(t);\n      }\n    } else if (!isUndefined(time)) {\n      var value_1 = args[0];\n      splitComma(time + \"\").forEach(function (eachTime) {\n        var realTime = _this.getUnitTime(eachTime);\n\n        if (value_1 instanceof SceneItem) {\n          var delay = value_1.getDelay();\n          var frames = value_1.toObject(!_this.hasFrame(realTime + delay));\n          var duration = value_1.getDuration();\n          var direction = value_1.getDirection();\n          var isReverse = direction.indexOf(\"reverse\") > -1;\n\n          for (var frameTime in frames) {\n            var nextTime = isReverse ? duration - parseFloat(frameTime) : parseFloat(frameTime);\n\n            _this.set(realTime + nextTime, frames[frameTime]);\n          }\n        } else if (args.length === 1 && isArray(value_1)) {\n          value_1.forEach(function (item) {\n            _this.set(realTime, item);\n          });\n        } else {\n          var frame = _this.newFrame(realTime);\n\n          frame.set.apply(frame, args);\n        }\n      });\n    }\n\n    this.needUpdate = true;\n    return this;\n  };\n  /**\n    * Get properties of the sceneItem at that time\n    * @param {Number} time - time\n    * @param {...String|Object} args property's name or properties\n    * @return {Number|String|PropertyObejct} property value\n    * @example\n  item.get(0, \"a\"); // item.getFrame(0).get(\"a\");\n  item.get(0, \"transform\", \"translate\"); // item.getFrame(0).get(\"transform\", \"translate\");\n    */\n\n\n  __proto.get = function (time) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var frame = this.getFrame(time);\n    return frame && frame.get.apply(frame, args);\n  };\n  /**\n    * remove properties to the sceneItem at that time\n    * @param {Number} time - time\n    * @param {...String|Object} [properties] - property names or values\n    * @return {SceneItem} An instance itself\n    * @example\n  item.remove(0, \"a\");\n    */\n\n\n  __proto.remove = function (time) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (args.length) {\n      var frame = this.getFrame(time);\n      frame && frame.remove.apply(frame, args);\n    } else {\n      this.removeFrame(time);\n    }\n\n    this.needUpdate = true;\n    return this;\n  };\n  /**\n    * Append the item or object at the last time.\n    * @param - the scene item or item object\n    * @return An instance itself\n    * @example\n  item.append(new SceneItem({\n    0: {\n        opacity: 0,\n    },\n    1: {\n        opacity: 1,\n    }\n  }));\n  item.append({\n    0: {\n        opacity: 0,\n    },\n    1: {\n        opacity: 1,\n    }\n  });\n  item.set(item.getDuration(), {\n    0: {\n        opacity: 0,\n    },\n    1: {\n        opacity: 1,\n    }\n  });\n    */\n\n\n  __proto.append = function (item) {\n    if (item instanceof SceneItem) {\n      this.set(this.getDuration(), item);\n    } else {\n      this.append(new SceneItem(item));\n    }\n\n    return this;\n  };\n  /**\n    * Push the front frames for the time and prepend the scene item or item object.\n    * @param - the scene item or item object\n    * @return An instance itself\n    */\n\n\n  __proto.prepend = function (item) {\n    if (item instanceof SceneItem) {\n      var unshiftTime = item.getDuration() + item.getDelay();\n      var firstFrame = this.getFrame(0); // remove first frame\n\n      this.removeFrame(0);\n      this.unshift(unshiftTime);\n      this.set(0, item);\n      this.set(unshiftTime + THRESHOLD, firstFrame);\n    } else {\n      this.prepend(new SceneItem(item));\n    }\n\n    return this;\n  };\n  /**\n   * Push out the amount of time.\n   * @param - time to push\n   * @example\n  item.get(0); // frame 0\n  item.unshift(3);\n  item.get(3) // frame 0\n   */\n\n\n  __proto.unshift = function (time) {\n    var _a = this,\n        times = _a.times,\n        items = _a.items;\n\n    var obj = {};\n    this.times = times.map(function (t) {\n      var time2 = toFixed(time + t);\n      obj[time2] = items[t];\n      return time2;\n    });\n    this.items = obj;\n    return this;\n  };\n  /**\n   * Get the frames in the item in object form.\n   * @return {}\n   * @example\n  item.toObject();\n  // {0: {display: \"none\"}, 1: {display: \"block\"}}\n   */\n\n\n  __proto.toObject = function (isStartZero) {\n    if (isStartZero === void 0) {\n      isStartZero = true;\n    }\n\n    var obj = {};\n    var delay = this.getDelay();\n    this.forEach(function (frame, time) {\n      obj[(!time && !isStartZero ? THRESHOLD : 0) + delay + time] = frame.clone();\n    });\n    return obj;\n  };\n  /**\n   * Specifies an element to synchronize items' keyframes.\n   * @param {string} selectors - Selectors to find elements in items.\n   * @return {SceneItem} An instance itself\n   * @example\n  item.setSelector(\"#id.class\");\n   */\n\n\n  __proto.setSelector = function (target) {\n    if (isFunction(target)) {\n      this.setElement(target(this.getId()));\n    } else {\n      this.setElement(target);\n    }\n\n    return this;\n  };\n  /**\n   * Get the elements connected to SceneItem.\n   */\n\n\n  __proto.getElements = function () {\n    return this.elements;\n  };\n  /**\n   * Specifies an element to synchronize item's keyframes.\n   * @param - elements to synchronize item's keyframes.\n   * @param - Make sure that you have peusdo.\n   * @return {SceneItem} An instance itself\n   * @example\n  item.setElement(document.querySelector(\"#id.class\"));\n  item.setElement(document.querySelectorAll(\".class\"));\n   */\n\n\n  __proto.setElements = function (target) {\n    return this.setElement(target);\n  };\n  /**\n   * Specifies an element to synchronize item's keyframes.\n   * @param - elements to synchronize item's keyframes.\n   * @param - Make sure that you have peusdo.\n   * @return {SceneItem} An instance itself\n   * @example\n  item.setElement(document.querySelector(\"#id.class\"));\n  item.setElement(document.querySelectorAll(\".class\"));\n   */\n\n\n  __proto.setElement = function (target) {\n    var state = this.state;\n    var elements = [];\n\n    if (!target) {\n      return this;\n    } else if (target === true || isString(target)) {\n      var selector = target === true ? \"\" + state.id : target;\n      var matches = /([\\s\\S]+)(:+[a-zA-Z]+)$/g.exec(selector);\n      elements = toArray($(matches ? matches[1] : selector, true));\n      state[SELECTOR] = selector;\n    } else {\n      elements = target instanceof Element ? [target] : toArray(target);\n    }\n\n    if (!elements.length) {\n      return this;\n    }\n\n    this.elements = elements;\n    this.setId(this.getId());\n    this.target = elements[0].style;\n\n    this.targetFunc = function (frame) {\n      var attributes = frame.get(\"attribute\");\n\n      if (attributes) {\n        var _loop_2 = function _loop_2(name) {\n          elements.forEach(function (el) {\n            el.setAttribute(name, attributes[name]);\n          });\n        };\n\n        for (var name in attributes) {\n          _loop_2(name);\n        }\n      }\n\n      if (frame.has(\"html\")) {\n        var html_1 = frame.get(\"html\");\n        elements.forEach(function (el) {\n          el.innerHTML = html_1;\n        });\n      }\n\n      var cssText = frame.toCSS();\n\n      if (state.cssText !== cssText) {\n        state.cssText = cssText;\n        elements.forEach(function (el) {\n          el.style.cssText += cssText;\n        });\n        return frame;\n      }\n    };\n\n    return this;\n  };\n\n  __proto.setTarget = function (target) {\n    this.target = target;\n\n    this.targetFunc = function (frame) {\n      var obj = frame.get();\n\n      for (var name in obj) {\n        target[name] = obj[name];\n      }\n    };\n\n    return this;\n  };\n  /**\n    * add css styles of items's element to the frame at that time.\n    * @param {Array} properties - elements to synchronize item's keyframes.\n    * @return {SceneItem} An instance itself\n    * @example\n  item.setElement(document.querySelector(\"#id.class\"));\n  item.setCSS(0, [\"opacity\"]);\n  item.setCSS(0, [\"opacity\", \"width\", \"height\"]);\n    */\n\n\n  __proto.setCSS = function (time, properties) {\n    this.set(time, fromCSS(this.elements, properties));\n    return this;\n  };\n\n  __proto.setTime = function (time, isTick, isParent, parentEasing) {\n    _super.prototype.setTime.call(this, time, isTick, isParent);\n\n    var iterationTime = this.getIterationTime();\n    var easing = this.getEasing() || parentEasing;\n    var frame = this.getNowFrame(iterationTime, easing);\n    var currentTime = this.getTime();\n    this.temp = frame;\n    /**\n     * This event is fired when timeupdate and animate.\n     * @event SceneItem#animate\n     * @param {Number} param.currentTime The total time that the animator is running.\n     * @param {Number} param.time The iteration time during duration that the animator is running.\n     * @param {Frame} param.frame frame of that time.\n     */\n\n    this.trigger(\"animate\", {\n      frame: frame,\n      currentTime: currentTime,\n      time: iterationTime\n    });\n    this.targetFunc && this.targetFunc(frame);\n    return this;\n  };\n  /**\n    * update property names used in frames.\n    * @return {SceneItem} An instance itself\n    * @example\n  item.update();\n    */\n\n\n  __proto.update = function () {\n    var names = {};\n    this.forEach(function (frame) {\n      updateFrame(names, frame.properties);\n    });\n    this.names = names;\n    this.needUpdate = false;\n    return this;\n  };\n  /**\n    * Create and add a frame to the sceneItem at that time\n    * @param {Number} time - frame's time\n    * @return {Frame} Created frame.\n    * @example\n  item.newFrame(time);\n    */\n\n\n  __proto.newFrame = function (time) {\n    var frame = this.getFrame(time);\n\n    if (frame) {\n      return frame;\n    }\n\n    frame = new Frame();\n    this.setFrame(time, frame);\n    return frame;\n  };\n  /**\n    * Add a frame to the sceneItem at that time\n    * @param {Number} time - frame's time\n    * @return {SceneItem} An instance itself\n    * @example\n  item.setFrame(time, frame);\n    */\n\n\n  __proto.setFrame = function (time, frame) {\n    var realTime = this.getUnitTime(time);\n    this.items[realTime] = frame;\n    addTime(this.times, realTime);\n    this.needUpdate = true;\n    return this;\n  };\n  /**\n    * get sceneItem's frame at that time\n    * @param {Number} time - frame's time\n    * @return {Frame} sceneItem's frame at that time\n    * @example\n  const frame = item.getFrame(time);\n    */\n\n\n  __proto.getFrame = function (time) {\n    return this.items[this.getUnitTime(time)];\n  };\n  /**\n    * remove sceneItem's frame at that time\n    * @param - frame's time\n    * @return {SceneItem} An instance itself\n    * @example\n  item.removeFrame(time);\n    */\n\n\n  __proto.removeFrame = function (time) {\n    var realTime = this.getUnitTime(time);\n    var items = this.items;\n    var index = this.times.indexOf(realTime);\n    delete items[realTime]; // remove time\n\n    if (index > -1) {\n      this.times.splice(index, 1);\n    }\n\n    this.needUpdate = true;\n    return this;\n  };\n  /**\n    * check if the item has a frame at that time\n    * @param {Number} time - frame's time\n    * @return {Boolean} true: the item has a frame // false: not\n    * @example\n  if (item.hasFrame(10)) {\n    // has\n  } else {\n    // not\n  }\n    */\n\n\n  __proto.hasFrame = function (time) {\n    return this.getUnitTime(time) in this.items;\n  };\n  /**\n    * Check if keyframes has propery's name\n    * @param - property's time\n    * @return {boolean} true: if has property, false: not\n    * @example\n  item.hasName([\"transform\", \"translate\"]); // true or not\n    */\n\n\n  __proto.hasName = function (args) {\n    this.needUpdate && this.update();\n    return isInProperties(this.names, args, true);\n  };\n  /**\n    * merge frame of the previous time at the next time.\n  * @param - The time of the frame to merge\n  * @param - The target frame\n    * @return {SceneItem} An instance itself\n    * @example\n  // getFrame(1) contains getFrame(0)\n  item.merge(0, 1);\n    */\n\n\n  __proto.mergeFrame = function (time, frame) {\n    if (frame) {\n      var toFrame = this.newFrame(time);\n      toFrame.merge(frame);\n    }\n\n    return this;\n  };\n  /**\n    * Get frame of the current time\n    * @param {Number} time - the current time\n    * @param {function} easing - the speed curve of an animation\n    * @return {Frame} frame of the current time\n    * @example\n  let item = new SceneItem({\n    0: {\n        display: \"none\",\n    },\n    1: {\n        display: \"block\",\n        opacity: 0,\n    },\n    2: {\n        opacity: 1,\n    }\n  });\n  // opacity: 0.7; display:\"block\";\n  const frame = item.getNowFrame(1.7);\n    */\n\n\n  __proto.getNowFrame = function (time, easing, isAccurate) {\n    var _this = this;\n\n    this.needUpdate && this.update();\n    var frame = new Frame();\n\n    var _a = getNearTimeIndex(this.times, time),\n        left = _a[0],\n        right = _a[1];\n\n    var realEasing = this.getEasing() || easing;\n    var nameObject = this.names;\n\n    if (this.hasName([TIMING_FUNCTION])) {\n      var nowEasing = this.getNowValue(time, [TIMING_FUNCTION], left, right, false, 0, true);\n      isFunction(nowEasing) && (realEasing = nowEasing);\n    }\n\n    if (isAccurate) {\n      var prevFrame = this.getFrame(time);\n      var prevNames = updateFrame({}, prevFrame.properties);\n\n      for (var name in ROLES) {\n        if (name in prevNames) {\n          prevNames[name] = nameObject[name];\n        }\n      }\n\n      nameObject = prevNames;\n    }\n\n    var names = getNames(nameObject, []);\n    names.forEach(function (properties) {\n      var value = _this.getNowValue(time, properties, left, right, isAccurate, realEasing, isFixed(properties));\n\n      if (isUndefined(value)) {\n        return;\n      }\n\n      frame.set(properties, value);\n    });\n    return frame;\n  };\n\n  __proto.load = function (properties, options) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    if (options === void 0) {\n      options = properties.options;\n    }\n\n    var _a;\n\n    options && this.setOptions(options);\n\n    if (isArray(properties)) {\n      this.set(properties);\n    } else if (properties.keyframes) {\n      this.set(properties.keyframes);\n    } else {\n      for (var time in properties) {\n        if (time !== \"options\") {\n          this.set((_a = {}, _a[time] = properties[time], _a));\n        }\n      }\n    }\n\n    if (options && options[DURATION]) {\n      this.setDuration(options[DURATION]);\n    }\n\n    return this;\n  };\n  /**\n     * clone SceneItem.\n     * @return {SceneItem} An instance of clone\n     * @example\n     * item.clone();\n     */\n\n\n  __proto.clone = function () {\n    var item = new SceneItem();\n    item.setOptions(this.state);\n    this.forEach(function (frame, time) {\n      item.setFrame(time, frame.clone());\n    });\n    return item;\n  };\n  /**\n     * executes a provided function once for each scene item.\n     * @param - Function to execute for each element, taking three arguments\n     * @return {Keyframes} An instance itself\n     */\n\n\n  __proto.forEach = function (callback) {\n    var times = this.times;\n    var items = this.items;\n    times.forEach(function (time) {\n      callback(items[time], time, items);\n    });\n    return this;\n  };\n\n  __proto.setOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    _super.prototype.setOptions.call(this, options);\n\n    var id = options.id,\n        selector = options.selector,\n        elements = options.elements,\n        element = options.element,\n        target = options.target;\n    id && this.setId(id);\n\n    if (target) {\n      this.setTarget(target);\n    } else if (selector) {\n      this.setSelector(selector);\n    } else if (elements || element) {\n      this.setElement(elements || element);\n    }\n\n    return this;\n  };\n\n  __proto.toCSS = function (playCondition, parentDuration, states) {\n    if (playCondition === void 0) {\n      playCondition = {\n        className: START_ANIMATION\n      };\n    }\n\n    if (parentDuration === void 0) {\n      parentDuration = this.getDuration();\n    }\n\n    if (states === void 0) {\n      states = [];\n    }\n\n    var itemState = this.state;\n    var selector = itemState[SELECTOR];\n\n    if (!selector) {\n      return \"\";\n    }\n\n    var originalDuration = this.getDuration();\n    itemState[DURATION] = originalDuration;\n    states.push(itemState);\n    var reversedStates = toArray(states).reverse();\n    var id = toId(getRealId(this));\n    var superParent = states[0];\n    var infiniteIndex = findIndex(reversedStates, function (state) {\n      return state[ITERATION_COUNT] === INFINITE || !isFinite(state[DURATION]);\n    }, states.length - 1);\n    var finiteStates = reversedStates.slice(0, infiniteIndex);\n    var duration = parentDuration || finiteStates.reduce(function (prev, cur) {\n      return (cur[DELAY] + prev * cur[ITERATION_COUNT]) / cur[PLAY_SPEED];\n    }, originalDuration);\n    var delay = reversedStates.slice(infiniteIndex).reduce(function (prev, cur) {\n      return (prev + cur[DELAY]) / cur[PLAY_SPEED];\n    }, 0);\n    var easingName = find(reversedStates, function (state) {\n      return state[EASING] && state[EASING_NAME];\n    }, itemState)[EASING_NAME];\n    var iterationCount = reversedStates[infiniteIndex][ITERATION_COUNT];\n    var fillMode = superParent[FILL_MODE];\n    var direction = reversedStates[infiniteIndex][DIRECTION];\n    var cssText = makeAnimationProperties({\n      fillMode: fillMode,\n      direction: direction,\n      iterationCount: iterationCount,\n      delay: delay + \"s\",\n      name: PREFIX + \"KEYFRAMES_\" + id,\n      duration: duration / superParent[PLAY_SPEED] + \"s\",\n      timingFunction: easingName\n    });\n    var selectors = splitComma(selector).map(function (sel) {\n      var matches = /([\\s\\S]+)(:+[a-zA-Z]+)$/g.exec(sel);\n\n      if (matches) {\n        return [matches[1], matches[2]];\n      } else {\n        return [sel, \"\"];\n      }\n    });\n    var className = playCondition.className;\n    var selectorCallback = playCondition.selector;\n    var preselector = isFunction(selectorCallback) ? selectorCallback(this, selector) : selectorCallback;\n    return \"\\n    \" + (preselector || selectors.map(function (_a) {\n      var sel = _a[0],\n          peusdo = _a[1];\n      return sel + \".\" + className + peusdo;\n    })) + \" {\" + cssText + \"}\\n    \" + selectors.map(function (_a) {\n      var sel = _a[0],\n          peusdo = _a[1];\n      return sel + \".\" + PAUSE_ANIMATION + peusdo;\n    }) + \" {\" + ANIMATION + \"-play-state: paused;}\\n    @\" + KEYFRAMES + \" \" + PREFIX + \"KEYFRAMES_\" + id + \"{\" + this._toKeyframes(duration, finiteStates, direction) + \"}\";\n  };\n  /**\n   * Export the CSS of the items to the style.\n   * @param - Add a selector or className to play.\n   * @return {SceneItem} An instance itself\n   */\n\n\n  __proto.exportCSS = function (playCondition, duration, options) {\n    if (!this.elements.length) {\n      return \"\";\n    }\n\n    var css = this.toCSS(playCondition, duration, options);\n    var isParent = options && !isUndefined(options[ITERATION_COUNT]);\n    !isParent && exportCSS(getRealId(this), css);\n    return this;\n  };\n\n  __proto.pause = function () {\n    _super.prototype.pause.call(this);\n\n    isPausedCSS(this) && this.pauseCSS();\n    return this;\n  };\n\n  __proto.pauseCSS = function () {\n    this.elements.forEach(function (element) {\n      addClass(element, PAUSE_ANIMATION);\n    });\n    return this;\n  };\n\n  __proto.endCSS = function () {\n    this.elements.forEach(function (element) {\n      removeClass(element, PAUSE_ANIMATION);\n      removeClass(element, START_ANIMATION);\n    });\n    setPlayCSS(this, false);\n    return this;\n  };\n\n  __proto.end = function () {\n    isEndedCSS(this) && this.endCSS();\n\n    _super.prototype.end.call(this);\n\n    return this;\n  };\n  /**\n    * Play using the css animation and keyframes.\n    * @param - Check if you want to export css.\n    * @param [playClassName=\"startAnimation\"] - Add a class name to play.\n    * @param - The shorthand properties for six of the animation properties.\n    * @see {@link https://www.w3schools.com/cssref/css3_pr_animation.asp}\n    * @example\n  item.playCSS();\n  item.playCSS(false, \"startAnimation\", {\n    direction: \"reverse\",\n    fillMode: \"forwards\",\n  });\n    */\n\n\n  __proto.playCSS = function (isExportCSS, playClassName, properties) {\n    if (isExportCSS === void 0) {\n      isExportCSS = true;\n    }\n\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    playCSS(this, isExportCSS, playClassName, properties);\n    return this;\n  };\n\n  __proto.addPlayClass = function (isPaused, playClassName, properties) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    var elements = this.elements;\n    var length = elements.length;\n    var cssText = makeAnimationProperties(properties);\n\n    if (!length) {\n      return;\n    }\n\n    if (isPaused) {\n      elements.forEach(function (element) {\n        removeClass(element, PAUSE_ANIMATION);\n      });\n    } else {\n      elements.forEach(function (element) {\n        element.style.cssText += cssText;\n\n        if (hasClass(element, START_ANIMATION)) {\n          removeClass(element, START_ANIMATION);\n          requestAnimationFrame(function () {\n            requestAnimationFrame(function () {\n              addClass(element, START_ANIMATION);\n            });\n          });\n        } else {\n          addClass(element, START_ANIMATION);\n        }\n      });\n    }\n\n    return elements[0];\n  };\n\n  __proto.getNowValue = function (time, properties, left, right, isAccurate, easing, usePrevValue) {\n    var times = this.times;\n    var length = times.length;\n    var prevTime;\n    var nextTime;\n    var prevFrame;\n    var nextFrame;\n    var isUndefinedLeft = isUndefined(left);\n    var isUndefinedRight = isUndefined(right);\n\n    if (isUndefinedLeft || isUndefinedRight) {\n      var indicies = getNearTimeIndex(times, time);\n      isUndefinedLeft && (left = indicies[0]);\n      isUndefinedRight && (right = indicies[1]);\n    }\n\n    for (var i = left; i >= 0; --i) {\n      var frame = this.getFrame(times[i]);\n\n      if (frame.has.apply(frame, properties)) {\n        prevTime = times[i];\n        prevFrame = frame;\n        break;\n      }\n    }\n\n    var prevValue = prevFrame && prevFrame.raw.apply(prevFrame, properties);\n\n    if (isAccurate && !isRole([properties[0]])) {\n      return prevTime === time ? prevValue : undefined;\n    }\n\n    if (usePrevValue) {\n      return prevValue;\n    }\n\n    for (var i = right; i < length; ++i) {\n      var frame = this.getFrame(times[i]);\n\n      if (frame.has.apply(frame, properties)) {\n        nextTime = times[i];\n        nextFrame = frame;\n        break;\n      }\n    }\n\n    var nextValue = nextFrame && nextFrame.raw.apply(nextFrame, properties);\n\n    if (!prevFrame || isUndefined(prevValue)) {\n      return nextValue;\n    }\n\n    if (!nextFrame || isUndefined(nextValue) || prevValue === nextValue) {\n      return prevValue;\n    }\n\n    return dotValue(time, Math.max(prevTime, 0), nextTime, prevValue, nextValue, easing);\n  };\n\n  __proto._toKeyframes = function (duration, states, direction) {\n    var _this = this;\n\n    var frames = {};\n    var times = this.times.slice();\n\n    if (!times.length) {\n      return \"\";\n    }\n\n    var originalDuration = this.getDuration();\n    !this.getFrame(0) && times.unshift(0);\n    !this.getFrame(originalDuration) && times.push(originalDuration);\n    var entries = getEntries(times, states);\n    var lastEntry = entries[entries.length - 1]; // end delay time\n\n    lastEntry[0] < duration && addEntry(entries, duration, lastEntry[1]);\n    var prevTime = -1;\n    return entries.map(function (_a) {\n      var time = _a[0],\n          keytime = _a[1];\n\n      if (!frames[keytime]) {\n        frames[keytime] = (!_this.hasFrame(keytime) || keytime === 0 || keytime === originalDuration ? _this.getNowFrame(keytime) : _this.getNowFrame(keytime, 0, true)).toCSS();\n      }\n\n      var frameTime = time / duration * 100;\n\n      if (frameTime - prevTime < THRESHOLD) {\n        frameTime += THRESHOLD;\n      }\n\n      prevTime = frameTime;\n      return Math.min(frameTime, 100) + \"%{\\n                \" + (time === 0 && !isDirectionReverse(0, 1, direction) ? \"\" : frames[keytime]) + \"\\n            }\";\n    }).join(\"\");\n  };\n\n  return SceneItem;\n}(Animator);\n/**\n * manage sceneItems and play Scene.\n * @sort 1\n */\n\n\nvar Scene = /*#__PURE__*/function (_super) {\n  __extends(Scene, _super);\n  /**\n  * @param - properties\n  * @param - options\n  * @example\n  const scene = new Scene({\n    item1: {\n      0: {\n        display: \"none\",\n      },\n      1: {\n        display: \"block\",\n        opacity: 0,\n      },\n      2: {\n        opacity: 1,\n      },\n    },\n    item2: {\n      2: {\n        opacity: 1,\n      },\n    }\n  });\n    */\n\n\n  function Scene(properties, options) {\n    var _this = _super.call(this) || this;\n\n    _this.items = new ListMap();\n\n    _this.load(properties, options);\n\n    return _this;\n  }\n\n  var __proto = Scene.prototype;\n\n  __proto.getDuration = function () {\n    var time = 0;\n    this.forEach(function (item) {\n      time = Math.max(time, item.getTotalDuration() / item.getPlaySpeed());\n    });\n    return time || this.state[DURATION];\n  };\n\n  __proto.setDuration = function (duration) {\n    var items = this.items;\n    var sceneDuration = this.getDuration();\n\n    if (duration === 0 || !isFinite(sceneDuration)) {\n      return this;\n    }\n\n    if (sceneDuration === 0) {\n      this.forEach(function (item) {\n        item.setDuration(duration);\n      });\n    } else {\n      var ratio_1 = duration / sceneDuration;\n      this.forEach(function (item) {\n        item.setDelay(item.getDelay() * ratio_1);\n        item.setDuration(item.getDuration() * ratio_1);\n      });\n    }\n\n    _super.prototype.setDuration.call(this, duration);\n\n    return this;\n  };\n  /**\n  * get item in scene by name\n  * @param - The item's name\n  * @return {Scene | SceneItem} item\n  * @example\n  const item = scene.getItem(\"item1\")\n  */\n\n\n  __proto.getItem = function (name) {\n    return this.items.get(name);\n  };\n  /**\n  * create item in scene\n  * @param {} name - name of item to create\n  * @param {} options - The option object of SceneItem\n  * @return {} Newly created item\n  * @example\n  const item = scene.newItem(\"item1\")\n  */\n\n\n  __proto.newItem = function (name, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (this.items.has(name)) {\n      return this.items.get(name);\n    }\n\n    var item = new SceneItem();\n    this.setItem(name, item);\n    item.setOptions(options);\n    return item;\n  };\n  /**\n  * remove item in scene\n  * @param - name of item to remove\n  * @return  An instance itself\n  * @example\n  const item = scene.newItem(\"item1\")\n   scene.removeItem(\"item1\");\n  */\n\n\n  __proto.removeItem = function (name) {\n    this.items.remove(name);\n    return this;\n  };\n  /**\n  * add a sceneItem to the scene\n  * @param - name of item to create\n  * @param - sceneItem\n  * @example\n  const item = scene.newItem(\"item1\")\n  */\n\n\n  __proto.setItem = function (name, item) {\n    item.setId(name);\n    this.items.set(name, item);\n    return this;\n  };\n\n  __proto.setTime = function (time, isTick, isParent, parentEasing) {\n    _super.prototype.setTime.call(this, time, isTick, isParent);\n\n    var iterationTime = this.getIterationTime();\n    var easing = this.getEasing() || parentEasing;\n    var frames = {};\n    this.forEach(function (item) {\n      item.setTime(iterationTime * item.getPlaySpeed() - item.getDelay(), isTick, true, easing);\n      frames[item.getId()] = item.temp;\n    });\n    this.temp = frames;\n    /**\n     * This event is fired when timeupdate and animate.\n     * @event Scene#animate\n     * @param {object} param The object of data to be sent to an event.\n     * @param {number} param.currentTime The total time that the animator is running.\n     * @param {number} param.time The iteration time during duration that the animator is running.\n     * @param {object} param.frames frames of that time.\n     * @example\n    const scene = new Scene({\n    a: {\n    0: {\n        opacity: 0,\n    },\n    1: {\n        opacity: 1,\n    }\n    },\n    b: {\n    0: {\n        opacity: 0,\n    },\n    1: {\n        opacity: 1,\n    }\n    }\n    }).on(\"animate\", e => {\n    console.log(e.frames);\n    // {a: Frame, b: Frame}\n    console.log(e.frames.a.get(\"opacity\"));\n    });\n         */\n\n    this.trigger(\"animate\", {\n      frames: frames,\n      currentTime: this.getTime(),\n      time: iterationTime\n    });\n    return this;\n  };\n  /**\n   * executes a provided function once for each scene item.\n   * @param - Function to execute for each element, taking three arguments\n   * @return {Scene} An instance itself\n   */\n\n\n  __proto.forEach = function (func) {\n    var items = this.items;\n    items.forEach(function (item, id, index, obj) {\n      func(item, id, index, obj);\n    });\n    return this;\n  };\n\n  __proto.toCSS = function (playCondition, duration, parentStates) {\n    if (duration === void 0) {\n      duration = this.getDuration();\n    }\n\n    if (parentStates === void 0) {\n      parentStates = [];\n    }\n\n    var totalDuration = !duration || !isFinite(duration) ? 0 : duration;\n    var styles = [];\n    var state = this.state;\n    state[DURATION] = this.getDuration();\n    this.forEach(function (item) {\n      styles.push(item.toCSS(playCondition, totalDuration, parentStates.concat(state)));\n    });\n    return styles.join(\"\");\n  };\n  /**\n   * Export the CSS of the items to the style.\n   * @param - Add a selector or className to play.\n   * @return {Scene} An instance itself\n   */\n\n\n  __proto.exportCSS = function (playCondition, duration, parentStates) {\n    var css = this.toCSS(playCondition, duration, parentStates);\n    (!parentStates || !parentStates.length) && exportCSS(getRealId(this), css);\n    return this;\n  };\n\n  __proto.append = function (item) {\n    item.setDelay(item.getDelay() + this.getDuration());\n    this.setItem(getRealId(item), item);\n  };\n\n  __proto.pauseCSS = function () {\n    return this.forEach(function (item) {\n      item.pauseCSS();\n    });\n  };\n\n  __proto.pause = function () {\n    _super.prototype.pause.call(this);\n\n    isPausedCSS(this) && this.pauseCSS();\n    this.forEach(function (item) {\n      item.pause();\n    });\n    return this;\n  };\n\n  __proto.endCSS = function () {\n    this.forEach(function (item) {\n      item.endCSS();\n    });\n    setPlayCSS(this, false);\n  };\n\n  __proto.end = function () {\n    isEndedCSS(this) && this.endCSS();\n\n    _super.prototype.end.call(this);\n\n    return this;\n  };\n\n  __proto.addPlayClass = function (isPaused, playClassName, properties) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    var animtionElement;\n    this.forEach(function (item) {\n      var el = item.addPlayClass(isPaused, playClassName, properties);\n      !animtionElement && (animtionElement = el);\n    });\n    return animtionElement;\n  };\n  /**\n  * Play using the css animation and keyframes.\n  * @param - Check if you want to export css.\n  * @param [playClassName=\"startAnimation\"] - Add a class name to play.\n  * @param - The shorthand properties for six of the animation properties.\n  * @return {Scene} An instance itself\n  * @see {@link https://www.w3schools.com/cssref/css3_pr_animation.asp}\n  * @example\n  scene.playCSS();\n  scene.playCSS(false, {\n  direction: \"reverse\",\n  fillMode: \"forwards\",\n  });\n  */\n\n\n  __proto.playCSS = function (isExportCSS, playClassName, properties) {\n    if (isExportCSS === void 0) {\n      isExportCSS = true;\n    }\n\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    playCSS(this, isExportCSS, playClassName, properties);\n    return this;\n  };\n  /**\n    * Set properties to the Scene.\n    * @param - properties\n    * @return An instance itself\n    * @example\n  scene.set({\n  \".a\": {\n      0: {\n          opacity: 0,\n      },\n      1: {\n          opacity: 1,\n      },\n  },\n  });\n  // 0\n  console.log(scene.getItem(\".a\").get(0, \"opacity\"));\n  // 1\n  console.log(scene.getItem(\".a\").get(1, \"opacity\"));\n    */\n\n\n  __proto.set = function (properties) {\n    this.load(properties);\n    return this;\n  };\n\n  __proto.load = function (properties, options) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    if (options === void 0) {\n      options = properties.options;\n    }\n\n    if (!properties) {\n      return this;\n    }\n\n    var selector = options && options[SELECTOR] || this.state[SELECTOR];\n\n    for (var name in properties) {\n      if (name === \"options\") {\n        continue;\n      }\n\n      var object = properties[name];\n      var item = void 0;\n\n      if (object instanceof Scene || object instanceof SceneItem) {\n        this.setItem(name, object);\n        item = object;\n      } else if (isFunction(object) && selector) {\n        var elements = IS_WINDOW ? $(\"\" + (isFunction(selector) ? selector(name) : name), true) : [];\n        var length = elements.length;\n        var scene = new Scene();\n\n        for (var i = 0; i < length; ++i) {\n          scene.newItem(i).setId().setElement(elements[i]).load(object(i, elements[i]));\n        }\n\n        this.setItem(name, scene);\n        continue;\n      } else {\n        item = this.newItem(name);\n        item.load(object);\n      }\n\n      selector && item.setSelector(selector);\n    }\n\n    this.setOptions(options);\n  };\n\n  __proto.setOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    _super.prototype.setOptions.call(this, options);\n\n    var selector = options.selector;\n\n    if (selector) {\n      this.state[SELECTOR] = selector;\n    }\n\n    return this;\n  };\n\n  __proto.setSelector = function (target) {\n    var state = this.state;\n    var selector = target || state[SELECTOR];\n    state[SELECTOR] = selector;\n    var isItFunction = isFunction(target);\n\n    if (selector) {\n      this.forEach(function (item, name) {\n        item.setSelector(isItFunction ? target(name) : selector);\n      });\n    }\n\n    return this;\n  };\n\n  __proto.start = function (delay) {\n    if (delay === void 0) {\n      delay = this.state[DELAY];\n    }\n\n    var result = _super.prototype.start.call(this, delay);\n\n    if (result) {\n      this.forEach(function (item) {\n        item.start(0);\n      });\n    } else {\n      this.forEach(function (item) {\n        item.setPlayState(RUNNING);\n      });\n    }\n\n    return result;\n  };\n  /**\n  * version info\n  * @type {string}\n  * @example\n  * Scene.VERSION // 1.1.5\n  */\n\n\n  Scene.VERSION = \"1.1.5\";\n  return Scene;\n}(Animator);\n\nfunction animate(properties, options) {\n  return new Scene(properties, options).play();\n}\n\nfunction animateItem(properties, options) {\n  return new SceneItem(properties, options).play();\n}\n\nexport default Scene;\nexport { Animator, EASE, EASE_IN, EASE_IN_OUT, EASE_OUT, EVENTS, FIXED, Frame, LINEAR, OPTIONS, ROLES, STEP_END, STEP_START, SceneItem, animate, animateItem, bezier, setAlias, setRole, steps };","map":null,"metadata":{},"sourceType":"module"}