{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: @moveable/matrix\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/moveable.git\nversion: 0.3.1\n*/\nfunction add(matrix, inverseMatrix, startIndex, endIndex, fromStart, k) {\n  for (var i = startIndex; i < endIndex; ++i) {\n    matrix[i] += matrix[fromStart + i - startIndex] * k;\n    inverseMatrix[i] += inverseMatrix[fromStart + i - startIndex] * k;\n  }\n}\n\nfunction swap(matrix, inverseMatrix, startIndex, endIndex, fromStart) {\n  for (var i = startIndex; i < endIndex; ++i) {\n    var v = matrix[i];\n    var iv = inverseMatrix[i];\n    matrix[i] = matrix[fromStart + i - startIndex];\n    matrix[fromStart + i - startIndex] = v;\n    inverseMatrix[i] = inverseMatrix[fromStart + i - startIndex];\n    inverseMatrix[fromStart + i - startIndex] = iv;\n  }\n}\n\nfunction divide(matrix, inverseMatrix, startIndex, endIndex, k) {\n  for (var i = startIndex; i < endIndex; ++i) {\n    matrix[i] /= k;\n    inverseMatrix[i] /= k;\n  }\n}\n\nfunction ignoreDimension(matrix, m, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = matrix.slice();\n\n  for (var i = 0; i < n; ++i) {\n    newMatrix[i * n + m - 1] = 0;\n    newMatrix[(m - 1) * n + i] = 0;\n  }\n\n  newMatrix[(m - 1) * (n + 1)] = 1;\n  return newMatrix;\n}\n\nfunction invert(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = matrix.slice();\n  var inverseMatrix = createIdentityMatrix(n);\n\n  for (var i = 0; i < n; ++i) {\n    var startIndex = n * i;\n    var endIndex = n * (i + 1);\n    var identityIndex = startIndex + i;\n\n    if (newMatrix[identityIndex] === 0) {\n      for (var j = i + 1; j < n; ++j) {\n        if (newMatrix[n * j + i]) {\n          swap(newMatrix, inverseMatrix, startIndex, endIndex, n * j);\n          break;\n        }\n      }\n    }\n\n    if (newMatrix[identityIndex]) {\n      divide(newMatrix, inverseMatrix, startIndex, endIndex, newMatrix[identityIndex]);\n    } else {\n      // no inverse matrix\n      return [];\n    }\n\n    for (var j = 0; j < n; ++j) {\n      var targetStartIndex = n * j;\n      var targetEndIndex = targetStartIndex + n;\n      var targetIndex = targetStartIndex + i;\n      var target = newMatrix[targetIndex];\n\n      if (target === 0 || i === j) {\n        continue;\n      }\n\n      add(newMatrix, inverseMatrix, targetStartIndex, targetEndIndex, startIndex, -target);\n    }\n  }\n\n  return inverseMatrix;\n}\n\nfunction transpose(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = [];\n\n  for (var i = 0; i < n; ++i) {\n    for (var j = 0; j < n; ++j) {\n      newMatrix[j * n + i] = matrix[n * i + j];\n    }\n  }\n\n  return newMatrix;\n}\n\nfunction getRad(pos1, pos2) {\n  var distX = pos2[0] - pos1[0];\n  var distY = pos2[1] - pos1[1];\n  var rad = Math.atan2(distY, distX);\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nfunction getOrigin(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var originMatrix = [];\n\n  for (var i = 0; i < n - 1; ++i) {\n    originMatrix[i] = matrix[(i + 1) * n - 1];\n  }\n\n  originMatrix[n - 1] = 0;\n  return originMatrix;\n}\n\nfunction convertPositionMatrix(matrix, n) {\n  var newMatrix = matrix.slice();\n\n  for (var i = matrix.length; i < n - 1; ++i) {\n    newMatrix[i] = 0;\n  }\n\n  newMatrix[n - 1] = 1;\n  return newMatrix;\n}\n\nfunction convertDimension(matrix, n, m) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  } // n < m\n\n\n  if (n === m) {\n    return matrix;\n  }\n\n  var newMatrix = createIdentityMatrix(m);\n  var length = Math.min(n, m);\n\n  for (var i = 0; i < length - 1; ++i) {\n    for (var j = 0; j < length - 1; ++j) {\n      newMatrix[i * m + j] = matrix[i * n + j];\n    }\n\n    newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];\n    newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];\n  }\n\n  newMatrix[m * m - 1] = matrix[n * n - 1];\n  return newMatrix;\n}\n\nfunction multiplies(n) {\n  var matrixes = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    matrixes[_i - 1] = arguments[_i];\n  }\n\n  var m = createIdentityMatrix(n);\n  matrixes.forEach(function (matrix) {\n    m = multiply(m, matrix, n);\n  });\n  return m;\n}\n\nfunction multiply(matrix, matrix2, n) {\n  var newMatrix = []; // n * m X m * k\n\n  var m = matrix.length / n;\n  var k = matrix2.length / m;\n\n  if (!m) {\n    return matrix2;\n  } else if (!k) {\n    return matrix;\n  }\n\n  for (var i = 0; i < n; ++i) {\n    for (var j = 0; j < k; ++j) {\n      newMatrix[i * k + j] = 0;\n\n      for (var l = 0; l < m; ++l) {\n        newMatrix[i * k + j] += matrix[i * m + l] * matrix2[l * k + j];\n      }\n    }\n  } // n * k\n\n\n  return newMatrix;\n}\n\nfunction multiplyCSS(matrix, matrix2, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = []; // n(y) * m(x) X m(y) * k(x)\n\n  var m = matrix.length / n;\n  var k = matrix2.length / m;\n\n  for (var i = 0; i < n; ++i) {\n    for (var j = 0; j < k; ++j) {\n      newMatrix[i + j * k] = 0;\n\n      for (var l = 0; l < m; ++l) {\n        newMatrix[i + j * k] += matrix[i + l * m] * matrix2[l + j * k];\n      }\n    }\n  } // n * k\n\n\n  return newMatrix;\n}\n\nfunction sum() {\n  var nums = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    nums[_i] = arguments[_i];\n  }\n\n  var length = nums.length;\n  var total = 0;\n\n  for (var i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n\n  return total;\n}\n\nfunction average() {\n  var nums = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    nums[_i] = arguments[_i];\n  }\n\n  var length = nums.length;\n  var total = 0;\n\n  for (var i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n\n  return length ? total / length : 0;\n}\n\nfunction plus(pos1, pos2) {\n  var length = Math.min(pos1.length, pos2.length);\n  var nextPos = pos1.slice();\n\n  for (var i = 0; i < length; ++i) {\n    nextPos[i] = nextPos[i] + pos2[i];\n  }\n\n  return nextPos;\n}\n\nfunction minus(pos1, pos2) {\n  var length = Math.min(pos1.length, pos2.length);\n  var nextPos = pos1.slice();\n\n  for (var i = 0; i < length; ++i) {\n    nextPos[i] = nextPos[i] - pos2[i];\n  }\n\n  return nextPos;\n}\n\nfunction caculate(matrix, matrix2, n) {\n  if (n === void 0) {\n    n = matrix2.length;\n  }\n\n  var result = multiply(matrix, matrix2, n);\n  var k = result[n - 1];\n  return result.map(function (v) {\n    return v / k;\n  });\n}\n\nfunction rotate(pos, rad) {\n  return caculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));\n}\n\nfunction convertCSStoMatrix(a) {\n  if (a.length === 6) {\n    return [a[0], a[2], a[4], a[1], a[3], a[5], 0, 0, 1];\n  }\n\n  return transpose(a);\n}\n\nfunction convertMatrixtoCSS(a) {\n  if (a.length === 9) {\n    return [a[0], a[3], a[1], a[4], a[2], a[5]];\n  }\n\n  return transpose(a);\n}\n\nfunction createRotateMatrix(rad, n) {\n  var cos = Math.cos(rad);\n  var sin = Math.sin(rad);\n  var m = createIdentityMatrix(n);\n  m[0] = cos;\n  m[1] = -sin;\n  m[n] = sin;\n  m[n + 1] = cos;\n  return m;\n}\n\nfunction createIdentityMatrix(n) {\n  var length = n * n;\n  var matrix = [];\n\n  for (var i = 0; i < length; ++i) {\n    matrix[i] = i % (n + 1) ? 0 : 1;\n  }\n\n  return matrix;\n}\n\nfunction createScaleMatrix(scale, n) {\n  var m = createIdentityMatrix(n);\n  var length = Math.min(scale.length, n - 1);\n\n  for (var i = 0; i < length; ++i) {\n    m[(n + 1) * i] = scale[i];\n  }\n\n  return m;\n}\n\nfunction createOriginMatrix(origin, n) {\n  var m = createIdentityMatrix(n);\n  var length = Math.min(origin.length, n - 1);\n\n  for (var i = 0; i < length; ++i) {\n    m[n * (i + 1) - 1] = origin[i];\n  }\n\n  return m;\n}\n\nfunction createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {\n  var x0 = pos0[0],\n      y0 = pos0[1];\n  var x1 = pos1[0],\n      y1 = pos1[1];\n  var x2 = pos2[0],\n      y2 = pos2[1];\n  var x3 = pos3[0],\n      y3 = pos3[1];\n  var u0 = nextPos0[0],\n      v0 = nextPos0[1];\n  var u1 = nextPos1[0],\n      v1 = nextPos1[1];\n  var u2 = nextPos2[0],\n      v2 = nextPos2[1];\n  var u3 = nextPos3[0],\n      v3 = nextPos3[1];\n  var matrix = [x0, y0, 1, 0, 0, 0, -u0 * x0, -u0 * y0, 0, 0, 0, x0, y0, 1, -v0 * x0, -v0 * y0, x1, y1, 1, 0, 0, 0, -u1 * x1, -u1 * y1, 0, 0, 0, x1, y1, 1, -v1 * x1, -v1 * y1, x2, y2, 1, 0, 0, 0, -u2 * x2, -u2 * y2, 0, 0, 0, x2, y2, 1, -v2 * x2, -v2 * y2, x3, y3, 1, 0, 0, 0, -u3 * x3, -u3 * y3, 0, 0, 0, x3, y3, 1, -v3 * x3, -v3 * y3];\n  var inverseMatrix = invert(matrix, 8);\n\n  if (!inverseMatrix.length) {\n    return [];\n  }\n\n  var h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);\n  h[8] = 1;\n  return convertDimension(h, 3, 4);\n}\n\nexport { average, caculate, convertCSStoMatrix, convertDimension, convertMatrixtoCSS, convertPositionMatrix, createIdentityMatrix, createOriginMatrix, createRotateMatrix, createScaleMatrix, createWarpMatrix, getOrigin, getRad, ignoreDimension, invert, minus, multiplies, multiply, multiplyCSS, plus, rotate, sum, transpose };","map":null,"metadata":{},"sourceType":"module"}