{"version":3,"file":"moveable.esm.js","sources":["../src/react-moveable/consts.ts","../src/react-moveable/utils.ts","../src/react-moveable/ables/triggerRender.ts","../src/react-moveable/getAbleDragger.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/DraggerUtils.ts","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/ables/Draggable.tsx","../src/react-moveable/CustomDragger.ts","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/renderDirection.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/Default.ts","../src/react-moveable/ables/consts.ts","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/Moveable.tsx"],"sourcesContent":["import { prefixCSS } from \"framework-utils\";\nimport getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    const defaultCursor\n        = degree45 === 135\n        ? \"nwse-resize\"\n        : degree45 === 45\n        ? \"nesw-resize\"\n        : degree45 === 90\n        ? \"ew-resize\"\n        : \"ns-resize\"; // 135\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};cursor: -webkit-image-set(url('${x1}') 1x, url('${x2}') 2x) 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent();\nexport const isWebkit\n    = agent.os.name.indexOf(\"ios\") > -1 || agent.browser.name.indexOf(\"safari\") > -1;\n\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = prefixCSS(PREFIX, `\n{\n\tposition: fixed;\n\twidth: 0;\n\theight: 0;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 3000;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\tposition: absolute;\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n\tbackground: #4af;\n\tmargin-top: -7px;\n    margin-left: -7px;\n    z-index: 10;\n}\n.line {\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tbackground: #4af;\n\ttransform-origin: 0px 0.5px;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n}\n.line.dashed:before {\n    position: absolute;\n    content: attr(data-size);\n    color: #4af;\n    font-size: 12px;\n    font-weight: bold;\n}\n.line.dashed.horizontal:before {\n    left: 50%;\n    transform: translateX(-50%);\n    bottom: 5px;\n}\n.line.dashed.vertical:before {\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.line.rotation-line {\n\theight: 40px;\n\twidth: 1px;\n    transform-origin: 0.5px 39.5px;\n    top: -40px;\n}\n.line.rotation-line .control {\n\tborder-color: #4af;\n\tbackground:#fff;\n\tcursor: alias;\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n\tmargin-left: -6px;\n\tpointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"] {\n\t${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n${isWebkit ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`);\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    s: [2, 3],\n    w: [2, 0],\n    e: [1, 3],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n","import { PREFIX, isWebkit } from \"./consts\";\nimport { prefixNames } from \"framework-utils\";\nimport { splitBracket, isUndefined, isObject, splitUnit, IObject } from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertCSStoMatrix, convertMatrixtoCSS,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, caculate,\n    multiplies,\n    minus,\n    getOrigin,\n    createScaleMatrix,\n    plus,\n    getRad,\n} from \"@moveable/matrix\";\n\nimport MoveableManager from \"./MoveableManager\";\nimport { MoveableManagerState, Able, MoveableClientRect } from \"./types\";\n\nexport function round(num: number) {\n    return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransform(target: SVGElement | HTMLElement, isInit: true): number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: false): \"none\" | number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: boolean) {\n    const transform = getComputedStyle(target).transform!;\n\n    if (!transform || (transform === \"none\" && !isInit)) {\n        return \"none\";\n    }\n    return getTransformMatrix(transform);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    const value = splitBracket(transform).value!;\n    return value.split(/s*,\\s*/g).map(v => parseFloat(v));\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = el.ownerSVGElement!.viewBox.baseVal;\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent ? el : el.parentElement;\n    let isEnd = false;\n    let position = \"relative\";\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const transform = style.transform;\n        position = style.position!;\n\n        if (position !== \"static\" || (transform && transform !== \"none\")) {\n            break;\n        }\n        target = target.parentElement;\n        position = \"relative\";\n    }\n    return {\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function caculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n    prevN?: number,\n): [number[], number[], number[], number[], string, number[], boolean] {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: number[][] = [];\n    const isSVGGraphicElement = el.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in el;\n    const originalContainer = container || document.body;\n    let isEnd = false;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    const offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n    if (prevMatrix) {\n        container = target.parentElement;\n    }\n\n    while (el && !isEnd) {\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const tagName = el.tagName.toLowerCase();\n        const position = style.position;\n        const isFixed = position === \"fixed\";\n        const styleTransform = style.transform!;\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(styleTransform));\n\n        if (!is3d && matrix.length === 16) {\n            is3d = true;\n            n = 4;\n            const matrixesLength = matrixes.length;\n\n            for (let i = 0; i < matrixesLength; ++i) {\n                matrixes[i] = convertDimension(matrixes[i], 3, 4);\n            }\n        }\n        if (is3d && matrix.length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n\n        let offsetLeft = (el as HTMLElement).offsetLeft;\n        let offsetTop = (el as HTMLElement).offsetTop;\n\n        if (isFixed) {\n            const containerClientRect = (container || document.documentElement).getBoundingClientRect();\n\n            offsetLeft -= containerClientRect.left;\n            offsetTop  -= containerClientRect.top;\n        }\n        // svg\n        const isSVG = isUndefined(offsetLeft);\n        let hasNotOffset = isSVG;\n        let origin: number[];\n        // inner svg element\n        if (hasNotOffset && tagName !== \"svg\") {\n            origin = isWebkit\n                ? getBeforeTransformOrigin(el as SVGElement)\n                : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n            hasNotOffset = false;\n\n            if (tagName === \"g\") {\n                offsetLeft = 0;\n                offsetTop = 0;\n            } else {\n                [\n                    offsetLeft, offsetTop, origin[0], origin[1],\n                ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n            }\n        } else {\n            origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n        }\n        if (tagName === \"svg\" && targetMatrix) {\n            matrixes.push(\n                getSVGMatrix(el as SVGSVGElement, n),\n                createIdentityMatrix(n),\n            );\n        }\n        const {\n            offsetParent,\n            isEnd: isOffsetEnd,\n            isStatic,\n        } = getOffsetInfo(el, container);\n\n        if (isWebkit && !hasNotOffset && !isSVG && isStatic && position === \"relative\") {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n\n            isEnd = isEnd || isOffsetEnd;\n        }\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n\n        if (!hasNotOffset && offsetContainer !== offsetParent) {\n            parentClientLeft = offsetParent.clientLeft;\n            parentClientTop = offsetParent.clientTop;\n        }\n        matrixes.push(\n            getAbsoluteMatrix(matrix, n, origin),\n            createOriginMatrix([\n                (hasNotOffset ? el : offsetLeft - el.scrollLeft + parentClientLeft) as any,\n                (hasNotOffset ? origin : offsetTop - el.scrollTop + parentClientTop) as any,\n            ], n),\n        );\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            isEnd = isOffsetEnd;\n        }\n\n    }\n    let mat = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n    const endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;\n\n    matrixes.reverse();\n    matrixes.forEach((matrix, i) => {\n        if (length - 2 === i) {\n            beforeMatrix = mat.slice();\n        }\n        if (length - 1 === i) {\n            offsetMatrix = mat.slice();\n        }\n\n        if (isObject(matrix[n - 1])) {\n            [matrix[n - 1], matrix[2 * n - 1]] =\n                getSVGOffset(\n                    matrix[n - 1] as any,\n                    endContainer,\n                    n,\n                    matrix[2 * n - 1] as any,\n                    mat,\n                    matrixes[i + 1],\n                );\n        }\n        mat = multiply(\n            mat,\n            matrix,\n            n,\n        );\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n    const transform = `${isMatrix3d ? \"matrix3d\" : \"matrix\"}(${\n        convertMatrixtoCSS(isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix)\n        })`;\n\n    return [\n        beforeMatrix, offsetMatrix, mat, targetMatrix, transform, transformOrigin, is3d,\n    ];\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const viewBox = (el as SVGSVGElement).viewBox.baseVal;\n    const viewBoxWidth = viewBox.width || clientWidth;\n    const viewBoxHeight = viewBox.height || clientHeight;\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = (el as SVGSVGElement).preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n - 1],\n        scaleMatrix[2 * n - 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox) {\n        return [0, 0];\n    }\n    const bbox = el.getBBox();\n    const svgElement = el.ownerSVGElement!;\n    const viewBox = svgElement.viewBox.baseVal;\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function caculatePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function caculatePoses(matrix: number[], width: number, height: number, n: number) {\n    const pos1 = caculatePosition(matrix, [0, 0], n);\n    const pos2 = caculatePosition(matrix, [width, 0], n);\n    const pos3 = caculatePosition(matrix, [0, height], n);\n    const pos4 = caculatePosition(matrix, [width, height], n);\n\n    return [pos1, pos2, pos3, pos4];\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function caculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = caculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    el: SVGElement,\n    container: HTMLElement | SVGElement,\n    n: number, origin: number[], beforeMatrix: number[], absoluteMatrix: number[]) {\n\n    const [width, height] = getSize(el);\n    const containerClientRect = container.getBoundingClientRect();\n    const rect = el.getBoundingClientRect();\n    const rectLeft = rect.left - containerClientRect.left + container.scrollLeft;\n    const rectTop = rect.top - containerClientRect.top + container.scrollTop;\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        absoluteMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = caculateRect(mat, width, height, n);\n    const posOrigin = caculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            caculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            caculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            absoluteMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = caculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\nexport function caculateMoveablePosition(matrix: number[], origin: number[], width: number, height: number): [\n    number[],\n    number[],\n    number[],\n    number[],\n    number[],\n    number[],\n    1 | -1,\n] {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = caculatePoses(matrix, width, height, n);\n    let [originX, originY] = caculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const center = [\n        (x1 + x2 + x3 + x4) / 4,\n        (y1 + y2 + y3 + y4) / 4,\n    ];\n    const pos1Rad = getRad(center, [x1, y1]);\n    const pos2Rad = getRad(center, [x2, y2]);\n    const direction =\n        (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) || (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n            ? 1 : -1;\n\n    return [\n        [left, top, right, bottom],\n        [originX, originY],\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n        direction,\n    ];\n}\nexport function getDistSize(vec: number[]) {\n    return  Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1],\n    ]);\n}\nexport function getLineStyle(pos1: number[], pos2: number[], rad: number = getRad(pos1, pos2)) {\n    const width = getDiagonalSize(pos1, pos2);\n\n    return {\n        transform: `translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad)`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translate(${x}px, ${y}px) rotate(${rotation}rad)`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = window.getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\nexport function getSize(\n    target: SVGElement | HTMLElement,\n    style: CSSStyleDeclaration = window.getComputedStyle(target),\n    isOffset?: boolean,\n    isBoxSizing: boolean = isOffset || style.boxSizing === \"border-box\",\n) {\n    let width = (target as HTMLElement).offsetWidth;\n    let height = (target as HTMLElement).offsetHeight;\n    const hasOffset = !isUndefined(width);\n\n    if ((isOffset || isBoxSizing) && hasOffset) {\n        return [width, height];\n    }\n    width = target.clientWidth;\n    height = target.clientHeight;\n\n    if (!hasOffset && !width && !height) {\n        const bbox = (target as SVGGraphicsElement).getBBox();\n\n        return [bbox.width, bbox.height];\n    }\n    if (isOffset || isBoxSizing) {\n        const borderLeft = parseFloat(style.borderLeftWidth!) || 0;\n        const borderRight = parseFloat(style.borderRightWidth!) || 0;\n        const borderTop = parseFloat(style.borderTopWidth!) || 0;\n        const borderBottom = parseFloat(style.borderBottomWidth!) || 0;\n\n        return [\n            width + borderLeft + borderRight,\n            height + borderTop + borderBottom,\n        ];\n    } else {\n        const paddingLeft = parseFloat(style.paddingLeft!) || 0;\n        const paddingRight = parseFloat(style.paddingRight!) || 0;\n        const paddingTop = parseFloat(style.paddingTop!) || 0;\n        const paddingBottom = parseFloat(style.paddingBottom!) || 0;\n\n        return [\n            width - paddingLeft - paddingRight,\n            height - paddingTop - paddingBottom,\n        ];\n    }\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nexport function getTargetInfo(\n    target?: HTMLElement | SVGElement,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    state?: Partial<MoveableManagerState> | false | undefined,\n): Partial<MoveableManagerState> {\n    let left = 0;\n    let top = 0;\n    let right = 0;\n    let bottom = 0;\n    let origin = [0, 0];\n    let pos1 = [0, 0];\n    let pos2 = [0, 0];\n    let pos3 = [0, 0];\n    let pos4 = [0, 0];\n    let offsetMatrix = createIdentityMatrix3();\n    let beforeMatrix = createIdentityMatrix3();\n    let matrix = createIdentityMatrix3();\n    let targetMatrix = createIdentityMatrix3();\n    let width = 0;\n    let height = 0;\n    let transformOrigin = [0, 0];\n    let direction: 1 | -1 = 1;\n    let beforeDirection: 1 | -1 = 1;\n    let is3d = false;\n    let targetTransform = \"\";\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let rotation = 0;\n\n    const prevMatrix = state ? state.beforeMatrix : undefined;\n    const prevN = state ? (state.is3d ? 4 : 3) : undefined;\n\n    if (target) {\n        if (state) {\n            width = state.width!;\n            height = state.height!;\n        } else {\n            const style = getComputedStyle(target);\n\n            width = (target as HTMLElement).offsetWidth;\n            height = (target as HTMLElement).offsetHeight;\n\n            if (isUndefined(width)) {\n                [width, height] = getSize(target, style, true);\n            }\n        }\n        [\n            beforeMatrix, offsetMatrix, matrix,\n            targetMatrix,\n            targetTransform, transformOrigin, is3d,\n        ] = caculateMatrixStack(target, container!, prevMatrix, prevN);\n\n        [\n            [left, top, right, bottom],\n            origin,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            direction,\n        ] = caculateMoveablePosition(matrix, transformOrigin, width, height);\n\n        const n = is3d ? 4 : 3;\n        let beforePos = [0, 0];\n\n        [\n            beforePos, beforeOrigin, , , , , beforeDirection,\n        ] = caculateMoveablePosition(offsetMatrix, plus(transformOrigin, getOrigin(targetMatrix, n)), width, height);\n\n        beforeOrigin = [\n            beforeOrigin[0] + beforePos[0] - left,\n            beforeOrigin[1] + beforePos[1] - top,\n        ];\n\n        targetClientRect = getClientRect(target);\n        containerClientRect = getClientRect(\n            getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body,\n        );\n        rotation = getRotationRad([pos1, pos2], direction);\n    }\n\n    return {\n        rotation,\n        targetClientRect,\n        containerClientRect,\n        beforeDirection,\n        direction,\n        target,\n        left,\n        top,\n        right,\n        bottom,\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n        width,\n        height,\n        beforeMatrix,\n        matrix,\n        targetTransform,\n        offsetMatrix,\n        targetMatrix,\n        is3d,\n        beforeOrigin,\n        origin,\n        transformOrigin,\n    };\n}\nexport function resetClientRect(): MoveableClientRect {\n    return { left: 0, right: 0, top: 0, width: 0, height: 0, bottom: 0 };\n}\nexport function getClientRect(el: HTMLElement | SVGElement) {\n    const { left, width, top, bottom, right, height } = el.getBoundingClientRect();\n\n    return {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height,\n    };\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\nexport function roundSign(num: number) {\n    return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\nexport function throttle(num: number, unit: number) {\n    if (!unit) {\n        return num;\n    }\n    return Math.round(num / unit) * unit;\n}\nexport function throttleArray(nums: number[], unit: number) {\n    nums.forEach((_, i) => {\n        nums[i] = throttle(nums[i], unit);\n    });\n    return nums;\n}\n\nexport function unset(self: any, name: string) {\n    if (self[name]) {\n        self[name].unset();\n        self[name] = null;\n    }\n}\n\nexport function getOrientationDirection(pos: number[], pos1: number[], pos2: number[]) {\n    return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);\n}\nexport function isInside(pos: number[], pos1: number[], pos2: number[], pos3: number[], pos4: number[]) {\n    const k1 = getOrientationDirection(pos, pos1, pos2);\n    const k2 = getOrientationDirection(pos, pos2, pos4);\n    const k3 = getOrientationDirection(pos, pos4, pos1);\n\n    const k4 = getOrientationDirection(pos, pos2, pos4);\n    const k5 = getOrientationDirection(pos, pos4, pos3);\n    const k6 = getOrientationDirection(pos, pos3, pos2);\n    const signs1 = [k1, k2, k3];\n    const signs2 = [k4, k5, k6];\n\n    if (\n        signs1.every(sign => sign >= 0)\n        || signs1.every(sign => sign <= 0)\n        || signs2.every(sign => sign >= 0)\n        || signs2.every(sign => sign <= 0)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: MoveableManager,\n    e: any,\n    params: Pick<T, Exclude<keyof T, \"target\" | \"clientX\" | \"clientY\" | \"inputEvent\" | \"datas\" | \"currentTarget\">>,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    return {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        datas: datas.datas,\n    } as any;\n}\n\nexport function triggerEvent<T extends IObject<any>, U extends keyof T>(\n    moveable: MoveableManager<T>,\n    name: U & string,\n    params: T[U] extends ((e: infer P) => any) | undefined ? P : {},\n): any {\n    return moveable.triggerEvent(name, params);\n}\n\nexport function getComputedStyle(el: HTMLElement | SVGElement, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(ables: Able[], methods: Array<keyof Able>) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function getKeepRatioHeight(width: number, isWidth: boolean, ratio: number) {\n    return width * (isWidth ? ratio : 1 / ratio);\n}\nexport function getKeepRatioWidth(height: number, isWidth: boolean, ratio: number) {\n    return height * (isWidth ? 1 / ratio : ratio);\n}\n\nexport function equals(a1: any, a2: any) {\n    return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n    const length = values.length - 1;\n    for (let i = 0; i < length; ++i) {\n        const value = values[i];\n\n        if (!isUndefined(value)) {\n            return value;\n        }\n    }\n\n    return values[length];\n}\n\nexport function groupBy<T>(arr: T[], func: (el: T, index: number, arr: T[]) => number) {\n    const group: T[][] = [];\n    const groupMap: IObject<T[]> = {};\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n\n        if (!groupMap[groupKey]) {\n            groupMap[groupKey] = [];\n            group.push(groupMap[groupKey]);\n        }\n        groupMap[groupKey].push(el);\n    });\n    return group;\n}\n\nexport function flat<T>(arr: T[][]): T[] {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(cur);\n    }, []);\n}\n","import MoveableManager from \"../MoveableManager\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function triggerRenderStart(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}Start`, params);\n}\nexport function triggerRender(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}`, params);\n}\nexport function triggerRenderEnd(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.sPinch,\n        isDrag: e.isDrag,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}End`, params);\n}\n","import MoveableManager from \"./MoveableManager\";\nimport Dragger, { OnDragStart, OnDrag, OnDragEnd, OnPinchEnd } from \"@daybrush/drag\";\nimport { Able } from \"./types\";\nimport { IObject } from \"@daybrush/utils\";\nimport { triggerRenderStart, triggerRenderEnd, triggerRender } from \"./ables/triggerRender\";\nimport MoveableGroup from \"./MoveableGroup\";\n\nfunction triggerAble<T extends IObject<any>>(\n    moveable: MoveableManager<any>,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: OnDragStart | OnDrag | OnDragEnd | OnPinchEnd,\n) {\n    const isStart = eventType === \"Start\";\n\n    if (isStart && eventAffix.indexOf(\"Control\") > -1 && moveable.areaElement === e.inputEvent.target) {\n        return false;\n    }\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType.indexOf(\"After\") > -1;\n\n    if (isStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Array<Able<T>> = (moveable as any)[ableType];\n    const events = ables.filter((able: any) => able[eventName]);\n    const results = events.filter((able: any) => {\n        const condition = isStart && able[conditionName];\n\n        if (!condition || condition(e.inputEvent.target, moveable)) {\n            return able[eventName](moveable, e);\n        }\n        return false;\n    });\n    const isUpdate = results.length;\n\n    if (isStart) {\n        if (events.length && !isUpdate) {\n            moveable.state.dragger = null;\n\n            if ((moveable as MoveableGroup).moveables) {\n                (moveable as MoveableGroup).moveables.forEach(childeMoveable => {\n                    childeMoveable.state.dragger = null;\n                });\n            }\n            return false;\n        }\n        triggerRenderStart(moveable, isGroup, e);\n    } else if (isEnd) {\n        triggerRenderEnd(moveable, isGroup, e);\n    } else if (isUpdate) {\n        triggerRender(moveable, isGroup, e);\n    }\n    if (isEnd) {\n        moveable.state.dragger = null;\n    }\n    if (!isStart && isUpdate) {\n        if (results.some(able => able.updateRect) && !isGroup) {\n            moveable.updateRect(eventType, false, false);\n        } else {\n            moveable.updateRect(eventType, true, false);\n        }\n    }\n    if ((!isStart && isUpdate) || (isEnd && !isUpdate)) {\n        moveable.forceUpdate();\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n}\nexport function getAbleDragger<T>(\n    moveable: MoveableManager<T>,\n    target: HTMLElement | SVGElement,\n    ableType: string,\n    eventAffix: string,\n) {\n    const options: IObject<any> = {\n        container: window,\n        pinchThreshold: moveable.props.pinchThreshold,\n    };\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            options[`${eventOperation}${eventType.toLowerCase()}`]\n                = (e: any) => triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n        });\n    });\n\n    return new Dragger(target!, options);\n}\n","import * as React from \"react\";\nimport { MOVEABLE_CSS, PREFIX } from \"./consts\";\nimport {\n    prefix, getLineStyle,\n    getTargetInfo,\n    unset,\n    createIdentityMatrix3,\n    isInside,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n    resetClientRect,\n    throttle,\n    flat,\n} from \"./utils\";\nimport styled from \"react-css-styled\";\nimport Dragger from \"@daybrush/drag\";\nimport { ref } from \"framework-utils\";\nimport { MoveableManagerProps, MoveableManagerState, Able, RectInfo } from \"./types\";\nimport { getAbleDragger } from \"./getAbleDragger\";\nimport CustomDragger from \"./CustomDragger\";\nimport { getRad } from \"@moveable/matrix\";\n\nconst ControlBoxElement = styled(\"div\", MOVEABLE_CSS);\n\nfunction renderLine(direction: string, pos1: number[], pos2: number[], index: number) {\n    const rad = getRad(pos1, pos2);\n    const rotation = direction ? (throttle(rad / Math.PI * 180, 15)) % 180 : -1;\n\n    return <div key={`line${index}`} className={prefix(\"line\", \"direction\", direction)}\n        data-rotation={rotation}\n        data-direction={direction} style={getLineStyle(pos1, pos2, rad)}></div>;\n}\nexport default class MoveableManager<T = {}, U = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState<U>> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        container: null,\n        origin: true,\n        edge: false,\n        parentMoveable: null,\n        parentPosition: null,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n    };\n    public state: MoveableManagerState<U> = {\n        conatainer: null,\n        target: null,\n        beforeMatrix: createIdentityMatrix3(),\n        matrix: createIdentityMatrix3(),\n        targetMatrix: createIdentityMatrix3(),\n        targetTransform: \"\",\n        is3d: false,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        transformOrigin: [0, 0],\n        direction: 1,\n        beforeDirection: 1,\n        beforeOrigin: [0, 0],\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        targetClientRect: resetClientRect(),\n        containerClientRect: resetClientRect(),\n        rotation: 0,\n    } as any;\n    public targetAbles: Array<Able<T>> = [];\n    public controlAbles: Array<Able<T>> = [];\n    public controlBox!: typeof ControlBoxElement extends new (...args: any[]) => infer K ? K : never;\n    public areaElement!: HTMLElement;\n    public targetDragger!: Dragger;\n    public controlDragger!: Dragger;\n    public customDragger!: CustomDragger;\n\n    public render() {\n        const props = this.props;\n        const { edge, parentPosition, className, target: propsTarget } = this.props;\n\n        this.checkUpdate();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const { left, top, pos1, pos2, pos3, pos4, target: stateTarget, direction } = this.state;\n        const groupTargets = (props as any).targets;\n        const isDisplay = ((groupTargets && groupTargets.length) || propsTarget) && stateTarget;\n        return (\n            <ControlBoxElement\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\")} ${className}`} style={{\n                    position: \"absolute\",\n                    display: isDisplay ? \"block\" : \"none\",\n                    transform: `translate(${left - parentLeft}px, ${top - parentTop}px) translateZ(50px)`,\n                }}>\n                {this.renderAbles()}\n                {renderLine(edge ? \"n\" : \"\", pos1, pos2, 0)}\n                {renderLine(edge ? \"e\" : \"\", pos2, pos4, 1)}\n                {renderLine(edge ? \"w\" : \"\", pos1, pos3, 2)}\n                {renderLine(edge ? \"s\" : \"\", pos3, pos4, 3)}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container } = props;\n\n        this.updateEvent(props);\n        if (!container && !parentMoveable) {\n            this.updateRect(\"End\", false, true);\n        }\n    }\n    public componentDidUpdate(prevProps: MoveableManagerProps<T>) {\n        this.updateEvent(prevProps);\n    }\n    public componentWillUnmount() {\n        unset(this, \"targetDragger\");\n        unset(this, \"controlDragger\");\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, container } = this.props;\n\n        return container!\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    public isMoveableElement(target: HTMLElement | SVGElement) {\n        return target && ((target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1);\n    }\n    public dragStart(e: MouseEvent | TouchEvent) {\n        if (this.targetDragger) {\n            this.targetDragger.onDragStart(e);\n        }\n    }\n    public isInside(clientX: number, clientY: number) {\n        const { pos1, pos2, pos3, pos4, target, targetClientRect } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        const { left, top } = targetClientRect;\n        const pos = [clientX - left, clientY - top];\n\n        return isInside(pos, pos1, pos2, pos4, pos3);\n    }\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const parentMoveable = this.props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        this.updateState(\n            getTargetInfo(target, container, container, isTarget ? state : undefined),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    public updateEvent(prevProps: MoveableManagerProps<T>) {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const target = this.props.target;\n        const prevTarget = prevProps.target;\n        const dragArea = this.props.dragArea;\n        const prevDragArea = prevProps.dragArea;\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isUnset = (!hasTargetAble && this.targetDragger)\n            || isTargetChanged\n            || prevDragArea !== dragArea;\n\n        if (isUnset) {\n            unset(this, \"targetDragger\");\n            this.updateState({ dragger: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlDragger\");\n        }\n\n        if (target && hasTargetAble && !this.targetDragger) {\n            if (dragArea) {\n                this.targetDragger = getAbleDragger(this, this.areaElement!, \"targetAbles\", \"\");\n            } else {\n                this.targetDragger = getAbleDragger(this, target!, \"targetAbles\", \"\");\n            }\n        }\n        if (!this.controlDragger && hasControlAble) {\n            this.controlDragger = getAbleDragger(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n        if (isUnset) {\n            this.unsetAbles();\n        }\n    }\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n        };\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n\n        this.updateState({ target, container });\n\n        if (!parentMoveable && (container || this.controlBox)) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    protected unsetAbles() {\n        if (this.targetAbles.filter(able => {\n            if (able.unset) {\n                able.unset(this);\n                return true;\n            }\n            return false;\n        }).length) {\n            this.forceUpdate();\n        }\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n\n        const enabledAbles = ables!.filter(able => able && props[able.name]);\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart]);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart]);\n\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            this.setState(nextState);\n        } else {\n            const state = this.state as any;\n\n            for (const name in nextState) {\n                state[name] = nextState[name];\n            }\n        }\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        const enabledAbles = ables.filter(able => able && props[able.name]);\n        const Renderer = { createElement: React.createElement };\n\n        return flat(filterAbles(enabledAbles, [\"render\"]).map(({ render }) => {\n            return render!(this, Renderer);\n        }));\n    }\n}\n","import { Client } from \"@daybrush/drag\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { PinchableProps, Able, SnappableState, OnPinchStart, OnPinch, OnPinchEnd } from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { getRad } from \"@moveable/matrix\";\n\nfunction getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport default {\n    name: \"pinchable\",\n    updateRect: true,\n    props: {\n        pinchable: Boolean,\n        pinchThreshold: Number,\n    },\n    pinchStart(\n        moveable: MoveableManager<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, touches, inputEvent, targets } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        const parentRotate = getRotatiion(touches);\n\n        pinchAbles.forEach(able => {\n            datas[able.name + \"Datas\"] = {};\n            const ableEvent: any = {\n                datas: datas[able.name + \"Datas\"],\n                clientX,\n                clientY,\n                inputEvent,\n                parentRotate,\n                pinchFlag: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, scale: pinchScale, distance, touches, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentRotate = getRotatiion(touches);\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            able[controlEventName]!(moveable, {\n                clientX,\n                clientY,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                parentDistance,\n                parentRotate,\n                pinchFlag: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, isPinch, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            able[controlEventName]!(moveable, {\n                clientX,\n                clientY,\n                isDrag: isPinch,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                pinchFlag: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroup, e: any) {\n        return this.pinchStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroup, e: any) {\n        return this.pinch(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroup, e: any) {\n        return this.pinchEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n","import MoveableGroup from \"./MoveableGroup\";\nimport { Able } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { hasClass, IObject, isFunction } from \"@daybrush/utils\";\nimport { prefix } from \"./utils\";\n\nexport function triggerChildAble<T extends Able>(\n    moveable: MoveableGroup,\n    able: T,\n    type: keyof T & string,\n    datas: IObject<any>,\n    eachEvent: ((movebale: MoveableManager, datas: IObject<any>) => any) | IObject<any>,\n    callback?: (moveable: MoveableManager<any>, datas: IObject<any>, result: any, index: number) => any,\n) {\n    const name = able.name!;\n    const ableDatas = datas[name] || (datas[name] = []);\n    const isEnd = !!type.match(/End$/g);\n    const childs = moveable.moveables.map((child, i) => {\n        const childDatas = ableDatas[i] || (ableDatas[i] = {});\n\n        const childEvent = isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;\n        const result = (able as any)[type]!(child,  { ...childEvent, datas: childDatas, parentFlag: true });\n\n        result && callback && callback(child, childDatas, result, i);\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n\n    return childs;\n}\nexport function directionCondition(target: HTMLElement | SVGElement) {\n    return hasClass(target, prefix(\"direction\"));\n}\n","import {\n    invert, caculate, minus, plus,\n    convertPositionMatrix, average,\n    createScaleMatrix, multiply,\n} from \"@moveable/matrix\";\nimport MoveableManager from \"./MoveableManager\";\nimport { caculatePoses, getAbsoluteMatrix, getAbsolutePosesByState } from \"./utils\";\nimport { splitUnit } from \"@daybrush/utils\";\nimport { MoveableManagerState, GroupableProps, ResizableProps } from \"./types\";\n\nexport function setDragStart(moveable: MoveableManager<any>, { datas }: any) {\n    const {\n        matrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = matrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(matrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = caculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix, is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function caculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n   return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n   const nextPoses = getPosesByDirection(poses, direction);\n\n   return [\n       average(...nextPoses.map(pos => pos[0])),\n       average(...nextPoses.map(pos => pos[1])),\n   ];\n}\nexport function getPosByReverseDirection(\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n    [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n    [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n    */\n\n    return getPosByDirection([pos4, pos3, pos2, pos1], direction);\n}\nfunction getStartPos(poses: number[][], direction: number[]) {\n    const [\n        startPos1,\n        startPos2,\n        startPos3,\n        startPos4,\n    ] = poses;\n    return getPosByReverseDirection([startPos1, startPos2, startPos3, startPos4], direction);\n}\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    direction: number[],\n) {\n    const poses = caculatePoses(matrix, width, height, n);\n    const pos = getPosByReverseDirection(poses, direction);\n    const distX = startPos[0] - pos[0];\n    const distY = startPos[1] - pos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\nexport function getScaleDist(\n    moveable: MoveableManager<any>,\n    scale: number[],\n    direction: number[],\n    dragClient?: number[],\n) {\n    const state = moveable.state;\n    const {\n        is3d,\n        left,\n        top,\n        width,\n        height,\n    } = state;\n\n    const n = is3d ? 4 : 3;\n    const groupable = moveable.props.groupable;\n    const nextMatrix = scaleMatrix(moveable.state, scale);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n\n    const startPos = dragClient ? dragClient : getStartPos(getAbsolutePosesByState(moveable.state), direction);\n\n    const dist = getDist(\n        startPos, nextMatrix, width, height, n,\n        direction,\n    );\n\n    return minus(dist, [groupLeft, groupTop]);\n}\n\nexport function getResizeDist(\n    moveable: MoveableManager<GroupableProps>,\n    width: number,\n    height: number,\n    // prevWidth: number,\n    // prevHeight: number,\n    direction: number[],\n    fixedPosition: number[],\n    transformOrigin: string[],\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const {\n        transformOrigin: prevOrigin,\n        targetMatrix,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = moveable.state;\n\n    const n = is3d ? 4 : 3;\n    const nextOrigin = caculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getStartDirection(\n    moveable: MoveableManager<ResizableProps>,\n    direction: number[],\n) {\n    const {\n        baseDirection = [-1, -1],\n    } = moveable.props;\n    return [\n        direction[0] ? direction[0] : baseDirection[0] * -1,\n        direction[1] ? direction[1] : baseDirection[1] * -1,\n    ];\n}\nexport function getFixedPosition(\n    moveable: MoveableManager<ResizableProps>,\n    direction: number[],\n) {\n    return getStartPos(getAbsolutePosesByState(moveable.state), direction);\n}\n","import MoveableManager from \"../MoveableManager\";\nimport {\n    Renderer,\n    SnappableProps,\n    SnappableState, Guideline,\n    SnapInfo, BoundInfo,\n    ScalableProps, ResizableProps, SnapPosInfo, RotatableProps, RectInfo,\n} from \"../types\";\nimport {\n    prefix, caculatePoses, getRect,\n    getAbsolutePosesByState, getAbsolutePoses, selectValue, throttle, roundSign, getDistSize, groupBy, flat\n} from \"../utils\";\nimport { directionCondition } from \"../groupUtils\";\nimport { isUndefined, IObject } from \"@daybrush/utils\";\nimport {\n    getPosByReverseDirection, getPosesByDirection,\n    getDragDist, scaleMatrix, getPosByDirection,\n} from \"../DraggerUtils\";\nimport { minus, rotate, getRad } from \"@moveable/matrix\";\nimport {\n    dragControlCondition as rotatableDragControlCondtion,\n} from \"./Rotatable\";\nimport { TINY_NUM } from \"../consts\";\n\nexport function snapStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n    const state = moveable.state;\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n\n    const {\n        horizontalGuidelines = [],\n        verticalGuidelines = [],\n        elementGuidelines = [],\n        bounds,\n        snapCenter,\n    } = moveable.props;\n\n    if (!bounds && !horizontalGuidelines.length && !verticalGuidelines.length && !elementGuidelines.length) {\n        return;\n    }\n\n    const {\n        containerClientRect: {\n            top: containerTop,\n            left: containerLeft,\n        },\n        targetClientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n    } = state;\n    const poses = getAbsolutePosesByState(state);\n    const targetLeft = Math.min(...poses.map(pos => pos[0]));\n    const targetTop = Math.min(...poses.map(pos => pos[1]));\n    const distLeft = roundSign(targetLeft - (clientLeft - containerLeft));\n    const distTop = roundSign(targetTop - (clientTop - containerTop));\n    const guidelines: Guideline[] = [];\n\n    elementGuidelines!.forEach(el => {\n        const rect = el.getBoundingClientRect();\n        const { top, left, width, height } = rect;\n        const elementTop = top - containerTop;\n        const elementBottom = elementTop + height;\n        const elementLeft = left - containerLeft;\n        const elementRight = elementLeft + width;\n        guidelines.push({ type: \"vertical\", element: el, pos: [\n            throttle(elementLeft + distLeft, 0.1),\n            elementTop,\n        ], size: height });\n        guidelines.push({ type: \"vertical\", element: el, pos: [\n            throttle(elementRight + distLeft, 0.1),\n            elementTop,\n        ], size: height });\n        guidelines.push({ type: \"horizontal\", element: el, pos: [\n            elementLeft,\n            throttle(elementTop + distTop, 0.1),\n        ], size: width });\n        guidelines.push({ type: \"horizontal\", element: el, pos: [\n            elementLeft,\n            throttle(elementBottom + distTop, 0.1),\n        ], size: width });\n\n        if (snapCenter) {\n            guidelines.push({\n                type: \"vertical\",\n                element: el,\n                pos: [\n                    throttle((elementLeft + elementRight) / 2 + distLeft, 0.1),\n                    elementTop,\n                ],\n                size: height,\n                center: true,\n            });\n            guidelines.push({\n                type: \"horizontal\",\n                element: el,\n                pos: [\n                    elementLeft,\n                    throttle((elementTop + elementBottom) / 2 + distTop, 0.1),\n                ],\n                size: width,\n                center: true,\n            });\n        }\n    });\n\n    state.guidelines = guidelines;\n    state.enableSnap = true;\n}\nfunction checkBounds(\n    moveable: MoveableManager<SnappableProps>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    snapThreshold?: number,\n) {\n    return {\n        vertical: checkBound(moveable, verticalPoses, true, snapThreshold),\n        horizontal: checkBound(moveable, horizontalPoses, false, snapThreshold),\n    };\n}\nfunction checkBound(\n    moveable: MoveableManager<SnappableProps>,\n    poses: number[],\n    isVertical: boolean,\n    snapThreshold: number = 0,\n): BoundInfo {\n    const bounds = moveable.props.bounds;\n\n    if (bounds) {\n        const startPos = bounds[isVertical ? \"left\" : \"top\"];\n        const endPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n        const minPos = Math.min(...poses);\n        const maxPos = Math.max(...poses);\n\n        if (!isUndefined(startPos) && startPos + snapThreshold > minPos) {\n            return {\n                isBound: true,\n                offset: minPos - startPos,\n                pos: startPos,\n            };\n        }\n        if (!isUndefined(endPos) && endPos - snapThreshold < maxPos) {\n            return {\n                isBound: true,\n                offset: maxPos - endPos,\n                pos: endPos,\n            };\n        }\n    }\n\n    return {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n}\nfunction checkSnap(\n    guidelines: Guideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    snapThreshold: number,\n    snapCenter: boolean,\n    snapElement: boolean,\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map(targetPos => {\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: Math.abs(offset),\n                guideline,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type, center, element } = guideline;\n            if (\n                (!snapElement && element)\n                || (!snapCenter && center)\n                || type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n        return {\n            pos: targetPos,\n            guidelineInfos,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    return {\n        isSnap: snapPosInfos.length > 0,\n        posInfos: snapPosInfos,\n    };\n}\nexport function hasGuidelines(\n    moveable: MoveableManager<any, any>,\n    ableName: string,\n): moveable is MoveableManager<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n        },\n        state: {\n            guidelines,\n            enableSnap,\n        },\n    } = moveable;\n\n    if (\n        !snappable\n        || !enableSnap\n        || (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        bounds\n        || (guidelines && guidelines.length)\n        || (verticalGuidelines && verticalGuidelines.length)\n        || (horizontalGuidelines && horizontalGuidelines.length)\n     ) {\n        return true;\n    }\n    return false;\n}\n\nexport function checkSnapPoses(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    snapCenter?: boolean,\n    customSnapThreshold?: number,\n) {\n    const {\n        guidelines,\n        containerClientRect: {\n            height: containerHeight,\n            width: containerWidth,\n        },\n     } = moveable.state;\n    const props = moveable.props;\n    const snapThreshold = selectValue<number>(customSnapThreshold, props.snapThreshold, 5);\n    const {\n        snapElement = true,\n        snapHorizontal = true,\n        snapVertical = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n    } = props;\n\n    const totalGuidelines = [...guidelines];\n\n    if (snapHorizontal && horizontalGuidelines) {\n        horizontalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"horizontal\", pos: [0, throttle(pos, 0.1)], size: containerWidth });\n        });\n    }\n    if (snapVertical && verticalGuidelines) {\n        verticalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"vertical\", pos: [throttle(pos, 0.1), 0], size: containerHeight });\n        });\n    }\n    return {\n        vertical: checkSnap(\n            totalGuidelines,\n            \"vertical\", posesX, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n        horizontal: checkSnap(\n            totalGuidelines,\n            \"horizontal\", posesY, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n    };\n}\nexport function checkSnaps(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    rect: {\n        left?: number,\n        top?: number,\n        bottom?: number,\n        right?: number,\n        center?: number,\n        middle?: number,\n    },\n    isCenter: boolean,\n    customSnapThreshold?: number,\n) {\n    const snapCenter = moveable.props.snapCenter;\n    const isSnapCenter = snapCenter! && isCenter;\n\n    let verticalNames: Array<\"left\" | \"center\" | \"right\"> = [\"left\", \"right\"];\n    let horizontalNames: Array<\"top\" | \"middle\" | \"bottom\"> = [\"top\", \"bottom\"];\n\n    if (isSnapCenter) {\n        verticalNames.push(\"center\");\n        horizontalNames.push(\"middle\");\n    }\n    verticalNames = verticalNames.filter(name => name in rect);\n    horizontalNames = horizontalNames.filter(name => name in rect);\n\n    return checkSnapPoses(\n        moveable,\n        verticalNames.map(name => rect[name]!),\n        horizontalNames.map(name => rect[name]!),\n        isSnapCenter,\n        customSnapThreshold,\n    );\n}\n\nfunction checkBoundOneWayDist(\n    moveable: MoveableManager<any, any>,\n    pos: number[],\n) {\n    const {\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalBoundOffset,\n        },\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalBoundOffset,\n        },\n    } = checkBounds(\n        moveable,\n        [pos[0]],\n        [pos[1]],\n    );\n    if (isHorizontalBound || isVerticalBound) {\n        let isVertical!: boolean;\n\n        if (isHorizontalBound && isVerticalBound) {\n            isVertical = Math.abs(horizontalBoundOffset) < Math.abs(verticalBoundOffset);\n        } else {\n            isVertical = isVerticalBound;\n        }\n        const offset = isVertical ? verticalBoundOffset : horizontalBoundOffset;\n        return {\n            isVertical,\n            offset,\n            dist: Math.abs(offset),\n        };\n    }\n    return;\n}\nfunction solveNextDist(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    isDirectionVertical: boolean,\n    datas: IObject<any>,\n) {\n    const sizeOffset = solveEquation(\n        pos1,\n        pos2,\n        -offset,\n        isVertical,\n    );\n\n    if (!sizeOffset) {\n        return NaN;\n    }\n    const [widthDist, heightDist] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return isDirectionVertical ? heightDist : widthDist;\n}\nfunction getFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    direction: number[],\n    is3d: boolean,\n) {\n    const nextPoses = caculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextPos = getPosByReverseDirection(nextPoses, direction);\n\n    return  getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\nfunction checkSnapOneWayPos(\n    moveable: MoveableManager<any, any>,\n    pos: number[],\n    reversePos: number[],\n    isDirectionVertical: boolean,\n    datas: any,\n) {\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = checkSnapPoses(\n        moveable,\n        [pos[0]],\n        [pos[1]],\n    );\n    const fixedHorizontal = Math.abs(reversePos[1] - pos[1]) < TINY_NUM;\n    const fixedVertical = Math.abs(reversePos[0] - pos[0]) < TINY_NUM;\n\n    let isVertical!: boolean;\n\n    const {\n        isSnap: isHorizontalSnap,\n        dist: horizontalDist,\n        offset: horizontalOffset,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const {\n        isSnap: isVerticalSnap,\n        dist: verticalDist,\n        offset: verticalOffset,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n\n    if (!isHorizontalSnap && !isVerticalSnap) {\n        // no snap\n        return NaN;\n    } else if (isHorizontalSnap && isVerticalSnap) {\n\n        if (horizontalDist === 0 && fixedHorizontal) {\n            isVertical = true;\n        } else if (verticalOffset === 0 && fixedVertical) {\n            isVertical = false;\n        } else {\n            isVertical = horizontalDist > verticalDist;\n        }\n    } else {\n        isVertical = isVerticalSnap;\n    }\n    return solveNextDist(\n        reversePos,\n        pos,\n        (isVertical ? verticalOffset : horizontalOffset),\n        isVertical,\n        isDirectionVertical,\n        datas,\n    );\n}\nexport function checkOneWayPos(\n    moveable: MoveableManager<any, any>,\n    poses: number[][],\n    reversePoses: number[][],\n    isDirectionVertical: boolean,\n    datas: any,\n) {\n    let posOffset = 0;\n    let boundInfo!: {\n        isVertical: boolean,\n        offset: number,\n        dist: number,\n    } | undefined;\n    let boundIndex = -1;\n    const boundInfos = poses.map(pos => checkBoundOneWayDist(moveable, pos));\n\n    boundInfos.forEach((info, i) => {\n        if (!info) {\n            return;\n        }\n        if (!boundInfo || boundInfo.dist < info.dist) {\n            boundInfo = info;\n            boundIndex = i;\n        }\n    });\n\n    if (boundInfo) {\n        const nextDist = solveNextDist(\n            reversePoses[boundIndex],\n            poses[boundIndex],\n            boundInfo.offset,\n            boundInfo.isVertical,\n            isDirectionVertical,\n            datas,\n        );\n\n        if (!isNaN(nextDist)) {\n            posOffset = nextDist;\n        }\n    } else  {\n        poses.some((pos, i) => {\n            const nextDist = checkSnapOneWayPos(moveable, pos, reversePoses[i], isDirectionVertical, datas);\n\n            if (isNaN(nextDist)) {\n                return false;\n            }\n            posOffset = nextDist;\n            return true;\n        });\n    }\n    return posOffset;\n}\nexport function checkOneWayDist(\n    moveable: MoveableManager<any, any>,\n    poses: number[][],\n    direction: number[],\n    datas: any,\n) {\n\n    const directionIndex = direction[0] !== 0 ? 0 : 1;\n    const isDirectionVertical = directionIndex > 0;\n    const reversePoses = poses.slice().reverse();\n    let directionPoses!: number[][];\n    let reverseDirectionPoses!: number[][];\n\n    if (moveable.props.keepRatio) {\n        directionPoses = [getPosByDirection(poses, direction)];\n        reverseDirectionPoses = [getPosByDirection(reversePoses, direction)];\n    } else {\n        directionPoses = getPosesByDirection(poses, direction);\n        reverseDirectionPoses = getPosesByDirection(reversePoses, direction);\n\n        directionPoses.push([\n            (directionPoses[0][0] + directionPoses[1][0]) / 2,\n            (directionPoses[0][1] + directionPoses[1][1]) / 2,\n        ]);\n        reverseDirectionPoses.reverse();\n        reverseDirectionPoses.push([\n            (reverseDirectionPoses[0][0] + reverseDirectionPoses[1][0]) / 2,\n            (reverseDirectionPoses[0][1] + reverseDirectionPoses[1][1]) / 2,\n        ]);\n    }\n\n    const posOffset = checkOneWayPos(moveable, directionPoses, reverseDirectionPoses, isDirectionVertical, datas);\n\n    const offset = [0, 0];\n\n    offset[directionIndex] = direction[directionIndex] * posOffset;\n    return offset;\n}\nexport function checkTwoWayDist(\n    moveable: MoveableManager<any, any>,\n    poses: number[][],\n    direction: number[],\n    datas: any,\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    is3d: boolean,\n) {\n    const directionPoses = getPosesByDirection(poses, direction);\n    const verticalDirection = [direction[0], direction[1] * -1];\n    const horizontalDirection = [direction[0] * -1, direction[1]];\n    const verticalPos = getPosByDirection(poses, verticalDirection);\n    const horizontalPos = getPosByDirection(poses, horizontalDirection);\n    const {\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalBoundOffset,\n        },\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalBoundOffset,\n        },\n    } = checkBounds(\n        moveable,\n        [directionPoses[0][0]],\n        [directionPoses[0][1]],\n    );\n\n    // share drag event\n    let widthDist = 0;\n    let heightDist = 0;\n\n    const verticalBoundInfo = checkBoundOneWayDist(moveable, verticalPos);\n    const horizontalBoundInfo = checkBoundOneWayDist(moveable, horizontalPos);\n    const isVeritcalDirectionBound = verticalBoundInfo && verticalBoundInfo.dist > Math.abs(verticalBoundOffset);\n    const isHorizontalDirectionBound\n        = horizontalBoundInfo && horizontalBoundInfo.dist > Math.abs(horizontalBoundOffset);\n\n    if (!isVeritcalDirectionBound && !isHorizontalDirectionBound) {\n        const {\n            horizontal: horizontalSnapInfo,\n            vertical: verticalSnapInfo,\n        } = checkSnapPoses(\n            moveable,\n            [directionPoses[0][0]],\n            [directionPoses[0][1]],\n        );\n\n        const horizontalOffset = getNearestSnapGuidelineInfo(horizontalSnapInfo).offset;\n        const verticalOffset = getNearestSnapGuidelineInfo(verticalSnapInfo).offset;\n\n        [widthDist, heightDist] = getDragDist({\n            datas,\n            distX: -(isVerticalBound ? verticalBoundOffset : verticalOffset),\n            distY: -(isHorizontalBound ? horizontalBoundOffset : horizontalOffset),\n        });\n    } else if (isVeritcalDirectionBound) {\n        // left to right, right to left\n        const reversePos = getPosByDirection(poses, [\n            verticalDirection[0] * -1,\n            verticalDirection[1],\n        ]);\n        const nextDist = solveNextDist(\n            reversePos, verticalPos,\n            verticalBoundInfo!.offset, verticalBoundInfo!.isVertical,\n            false, datas,\n        );\n        if (!isNaN(nextDist)) {\n            widthDist = nextDist;\n        }\n        const nextPoses = getFixedPoses(\n            matrix,\n            width + direction[0] * widthDist,\n            height + direction[1] * heightDist,\n            fixedPos,\n            direction,\n            is3d,\n        );\n        heightDist = checkOneWayPos(\n            moveable,\n            [getPosByDirection(nextPoses, direction)],\n            [getPosByDirection(nextPoses, verticalDirection)] ,\n            true,\n            datas,\n        );\n    } else {\n        // top to bottom, bottom to top\n        const reversePos = getPosByDirection(poses, [\n            horizontalDirection[0] * -1,\n            horizontalDirection[1],\n        ]);\n        const nextDist = solveNextDist(\n            reversePos, verticalPos,\n            horizontalBoundInfo!.offset, horizontalBoundInfo!.isVertical,\n            true, datas,\n        );\n        if (!isNaN(nextDist)) {\n            heightDist = nextDist;\n        }\n        const nextPoses = getFixedPoses(\n            matrix,\n            width + direction[0] * widthDist,\n            height + direction[1] * heightDist,\n            fixedPos,\n            direction,\n            is3d,\n        );\n        widthDist = checkOneWayPos(\n            moveable,\n            [getPosByDirection(nextPoses, direction)],\n            [getPosByDirection(nextPoses, horizontalDirection)] ,\n            false,\n            datas,\n        );\n    }\n\n    return [\n        direction[0] * widthDist,\n        direction[1] * heightDist,\n    ];\n}\nexport function checkSizeDist(\n    moveable: MoveableManager<any, any>,\n    matrix: number[],\n    width: number,\n    height: number,\n    direction: number[],\n    snapDirection: number[],\n    datas: any,\n    is3d: boolean,\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const fixedPos = getPosByReverseDirection(poses, snapDirection);\n    const nextPoses = getFixedPoses(matrix, width, height, fixedPos, direction, is3d);\n\n    if (direction[0] && direction[1]) {\n        return checkTwoWayDist(\n            moveable, nextPoses, direction, datas,\n            matrix, width, height, fixedPos, is3d,\n        );\n    } else {\n        return checkOneWayDist(moveable, nextPoses, direction, datas);\n    }\n\n}\n\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const [\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    ] = relativePoses;\n    const nextPos1 = rotate(pos1, rad);\n    const nextPos2 = rotate(pos2, rad);\n    const nextPos3 = rotate(pos3, rad);\n    const nextPos4 = rotate(pos4, rad);\n\n    return [nextPos1, nextPos2, nextPos3, nextPos4].some(pos => {\n        return (pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > TINY_NUM)\n            || (pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > TINY_NUM)\n            || (pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > TINY_NUM)\n            || (pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > TINY_NUM);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos);\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\nexport function checkSnapRotate(\n    moveable: MoveableManager<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.bounds;\n\n    if (!bounds || !hasGuidelines(moveable, \"resizable\")) {\n        return rotation;\n    }\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds;\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = rect;\n\n    const rad = rotation * Math.PI / 180;\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n    const relativePos1 = minus(pos1, origin);\n    const relativePos2 = minus(pos2, origin);\n    const relativePos3 = minus(pos3, origin);\n    const relativePos4 = minus(pos4, origin);\n    const relativePoses = [\n        relativePos1,\n        relativePos2,\n        relativePos3,\n        relativePos4,\n    ];\n    const nextPos1 = rotate(relativePos1, rad);\n    const nextPos2 = rotate(relativePos2, rad);\n    const nextPos3 = rotate(relativePos3, rad);\n    const nextPos4 = rotate(relativePos4, rad);\n    const nextPoses = [nextPos1, nextPos2, nextPos3, nextPos4];\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return rotation;\n    }\n    const canBounds: Array<[number[], number, number]> = [];\n    nextPoses.forEach(nextPos => {\n        if (nextPos[0] < relativeLeft) {\n            canBounds.push([nextPos, relativeLeft, 0]);\n        }\n        if (nextPos[0] > relativeRight) {\n            canBounds.push([nextPos, relativeRight, 0]);\n        }\n        if (nextPos[1] < relativeTop) {\n            canBounds.push([nextPos, relativeTop, 1]);\n        }\n        if (nextPos[1] > relativeBottom) {\n            canBounds.push([nextPos, relativeBottom, 1]);\n        }\n    });\n    const length = canBounds.length;\n\n    for (let i = 0; i < length; ++i) {\n        const [vec, boundPos, index] = canBounds[i];\n        const relativeRad1 = getRad([0, 0], vec);\n        const result = boundRotate(vec, boundPos, index).filter(relativeRad2 => {\n            return !isBoundRotate(relativePoses, boundRect, rad + relativeRad2 - relativeRad1);\n        });\n\n        if (result.length) {\n            return throttle((rad + result[0] - relativeRad1) * 180 / Math.PI, TINY_NUM);\n        }\n    }\n    return rotation;\n}\nexport function checkSnapSize(\n    moveable: MoveableManager<any, any>,\n    width: number,\n    height: number,\n    direction: number[],\n    datas: any,\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const {\n        matrix,\n        is3d,\n    } = moveable.state;\n    return checkSizeDist(moveable, matrix, width, height, direction, direction, datas, is3d);\n}\nexport function checkSnapScale(\n    moveable: MoveableManager<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    snapDirection: number[],\n    datas: any,\n) {\n    const {\n        width,\n        height,\n    } = datas;\n\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const sizeDist = checkSizeDist(\n        moveable, scaleMatrix(datas, scale),\n        width, height,\n        direction,\n        snapDirection,\n        datas, datas.is3d,\n    );\n\n    return [\n        sizeDist[0] / width,\n        sizeDist[1] / height,\n    ];\n}\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean,\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return;\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return;\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManager<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    poses: number[][],\n    snapDirection: number[],\n) {\n    if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n        const nextPoses = [];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            poses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n        return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n    } else {\n        let nextPoses!: number[][];\n\n        if (moveable.props.keepRatio) {\n            nextPoses = [getPosByDirection(poses, snapDirection)];\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n        return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n    }\n}\nexport function startCheckSnapDrag(\n    moveable: MoveableManager<any, any>,\n    datas: any,\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\nexport function checkSnapDrag(\n    moveable: MoveableManager<any, any>,\n    distX: number,\n    distY: number,\n    datas: any,\n) {\n    const snapVerticalInfo = {\n        isSnap: false,\n        isBound: false,\n        offset: 0,\n    };\n    const snapHorizontalInfo = {\n        isSnap: false,\n        isBound: false,\n        offset: 0,\n    };\n\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [snapVerticalInfo, snapHorizontalInfo];\n    }\n    const poses = getAbsolutePoses(\n        datas.absolutePoses,\n        [distX, distY],\n    );\n    const { left, right, top, bottom } = getRect(poses);\n\n    const snapInfos = checkSnaps(moveable, {\n        left,\n        right,\n        top,\n        bottom,\n        center: (left + right) / 2,\n        middle: (top + bottom) / 2,\n    }, true);\n    const boundInfos = checkBounds(moveable, [left, right], [top, bottom]);\n\n    if (boundInfos.vertical.isBound) {\n        snapVerticalInfo.offset = boundInfos.vertical.offset;\n        snapVerticalInfo.isSnap = true;\n        snapVerticalInfo.isBound = true;\n    } else if (snapInfos.vertical.isSnap) {\n        // has vertical guidelines\n        snapVerticalInfo.offset = snapInfos.vertical.posInfos[0].guidelineInfos[0].offset;\n        snapVerticalInfo.isSnap = true;\n    }\n    if (boundInfos.horizontal.isBound) {\n        snapHorizontalInfo.offset = boundInfos.horizontal.offset;\n        snapHorizontalInfo.isSnap = true;\n        snapHorizontalInfo.isBound = true;\n    } else if (snapInfos.horizontal.isSnap) {\n        // has horizontal guidelines\n        snapHorizontalInfo.offset = snapInfos.horizontal.posInfos[0].guidelineInfos[0].offset;\n        snapHorizontalInfo.isSnap = true;\n    }\n\n    return [\n        snapVerticalInfo,\n        snapHorizontalInfo,\n    ];\n}\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: Guideline[] = [];\n\n    posInfos.forEach(posInfo => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (guidelines.indexOf(guideline) > -1) {\n                return;\n            }\n            guidelines.push(guideline);\n        });\n    });\n\n    return guidelines;\n}\n\nfunction getElementGuidelineDist(\n    elementPos: number,\n    elementSize: number,\n    targetPos: number,\n    targetSize: number,\n) {\n    // relativePos < 0  => element(l)  ---  (r)target\n    // relativePos > 0  => target(l)   ---  (r)element\n    const relativePos = elementPos - targetPos;\n    const startPos = relativePos < 0 ? relativePos + elementSize : targetSize;\n    const endPos = relativePos < 0 ? 0 : relativePos;\n    const size = endPos - startPos;\n\n    return {\n        size,\n        pos: startPos,\n    };\n}\nexport default {\n    name: \"snappable\",\n    props: {\n        snappable: [Boolean, Array],\n        snapCenter: Boolean,\n        snapHorizontal: Boolean,\n        snapVertical: Boolean,\n        snapElement: Boolean,\n        snapThreshold: Number,\n        horizontalGuidelines: Array,\n        verticalGuidelines: Array,\n        elementGuidelines: Array,\n        bounds: Object,\n    } as const,\n    render(moveable: MoveableManager<SnappableProps, SnappableState>, React: Renderer): any[] {\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1, pos2, pos3, pos4,\n            snapRenderInfo,\n            targetClientRect,\n            containerClientRect,\n        } = moveable.state;\n\n        const clientLeft = targetClientRect.left - containerClientRect.left;\n        const clientTop = targetClientRect.top - containerClientRect.top;\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n\n        if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n        const {\n            snapThreshold = 5,\n        } = moveable.props;\n        const poses = getAbsolutePosesByState(moveable.state);\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const verticalSnapPoses: number[] = [];\n        const horizontalSnapPoses: number[] = [];\n        const verticalGuildelines: Guideline[] = [];\n        const horizontalGuidelines: Guideline[] = [];\n        const snapInfos: Array<{ vertical: SnapInfo, horizontal: SnapInfo }> = [];\n\n        if (snapRenderInfo.direction) {\n            snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));\n        }\n        if (snapRenderInfo.snap) {\n            const rect = getRect(poses);\n\n            if (snapRenderInfo.center) {\n                (rect as any).middle = (rect.top + rect.bottom) / 2;\n                (rect as any).center = (rect.left + rect.right) / 2;\n            }\n            snapInfos.push(checkSnaps(moveable, rect, true, 1));\n        }\n        snapInfos.forEach(snapInfo => {\n            const {\n                vertical: {\n                    posInfos: verticalPosInfos,\n                },\n                horizontal: {\n                    posInfos: horizontalPosInfos,\n                },\n            } = snapInfo;\n            verticalSnapPoses.push(...verticalPosInfos.map(posInfo => posInfo.pos));\n            horizontalSnapPoses.push(...horizontalPosInfos.map(posInfo => posInfo.pos));\n            verticalGuildelines.push(...getSnapGuidelines(verticalPosInfos));\n            horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n        });\n        const {\n            vertical: {\n                isBound: isVerticalBound,\n                pos: verticalBoundPos,\n            },\n            horizontal: {\n                isBound: isHorizontalBound,\n                pos: horizontalBoundPos,\n            },\n        } = checkBounds(moveable, [left, right], [top, bottom], 1);\n\n        if (isVerticalBound && verticalSnapPoses.indexOf(verticalBoundPos) < 0) {\n            verticalSnapPoses.push(verticalBoundPos);\n        }\n        if (isHorizontalBound && horizontalSnapPoses.indexOf(horizontalBoundPos) < 0) {\n            horizontalSnapPoses.push(horizontalBoundPos);\n        }\n\n        const elementVerticalGroup = groupBy(verticalGuildelines.filter(({ element }) => element), ({ pos }) => {\n            return Math.min(0, pos[1] - clientTop) < 0 ? -pos[0] : pos[0];\n        });\n        const elementHorizontalGroup = groupBy(horizontalGuidelines.filter(({ element }) => element), ({ pos }) => {\n            return Math.min(0, pos[0] - clientLeft) < 0 ? -pos[1] : pos[1];\n        });\n\n        elementHorizontalGroup.forEach(elementGuidelines => {\n            elementGuidelines.sort((a, b) => {\n                return getElementGuidelineDist(a.pos[0], a.size, clientLeft, width).size\n                    - getElementGuidelineDist(b.pos[0], a.size, clientLeft, width).size;\n            });\n        });\n        elementVerticalGroup.forEach(elementGuidelines => {\n            elementGuidelines.sort((a, b) => {\n                return getElementGuidelineDist(a.pos[1], a.size, clientTop, height).size\n                    - getElementGuidelineDist(b.pos[1], a.size, clientTop, height).size;\n            });\n        });\n        return [\n            ...flat(elementHorizontalGroup.map((elementGuidelines, i) => {\n                return elementGuidelines.map(({ pos, size}, j) => {\n                    const {\n                        pos: lineLeft,\n                        size: lineSize,\n                    } = getElementGuidelineDist(pos[0], size, clientLeft, width);\n\n                    if (lineSize < snapThreshold) {\n                        return null;\n                    }\n                    return <div className={prefix(\n                        \"line\",\n                        \"horizontal\",\n                        \"guideline\",\n                        \"dashed\",\n                    )}\n                    data-size={!j ? parseFloat(lineSize.toFixed(4)) : \"\"}\n                    key={`horizontalLinkGuidline${i}-${j}`} style={{\n                        left: `${minLeft + lineLeft}px`,\n                        top: `${-targetTop + pos[1]}px`,\n                        width: `${lineSize}px`,\n                    }} />;\n                });\n            })),\n            ...flat(elementVerticalGroup.map((elementGuidelines, i) => {\n                return elementGuidelines.map(({ pos, size}, j) => {\n                    const {\n                        pos: lineTop,\n                        size: lineSize,\n                    } = getElementGuidelineDist(pos[1], size, clientTop, height);\n\n                    if (lineSize < snapThreshold) {\n                        return null;\n                    }\n                    return <div className={prefix(\n                        \"line\",\n                        \"vertical\",\n                        \"guideline\",\n                        \"dashed\",\n                    )}\n                    data-size={!j ? parseFloat(lineSize.toFixed(4)) : \"\"}\n                    key={`verticalLinkGuidline${i}-${j}`} style={{\n                        top: `${lineTop}px`,\n                        left: `${-targetLeft + pos[0]}px`,\n                        height: `${lineSize}px`,\n                    }} />;\n                });\n            })),\n            ...verticalSnapPoses.map((pos, i) => {\n                return <div className={prefix(\n                    \"line\",\n                    \"vertical\",\n                    \"guideline\",\n                    \"target\",\n                    \"bold\",\n                )} key={`verticalTargetGuidline${i}`} style={{\n                    top: `${minTop}px`,\n                    left: `${-targetLeft + pos}px`,\n                    height: `${height}px`,\n                }} />;\n            }),\n            ...horizontalSnapPoses.map((pos, i) => {\n                return <div className={prefix(\n                    \"line\",\n                    \"horizontal\",\n                    \"guideline\",\n                    \"target\",\n                    \"bold\",\n                )} key={`horizontalTargetGuidline${i}`} style={{\n                    top: `${-targetTop + pos}px`,\n                    left: `${minLeft}px`,\n                    width: `${width}px`,\n                }} />;\n            }),\n            ...verticalGuildelines.map((guideline, i) => {\n                const { pos, size, element } = guideline;\n\n                return <div className={prefix(\n                    \"line\",\n                    \"vertical\",\n                    \"guideline\",\n                    element ? \"bold\" : \"\",\n                )} key={`verticalGuidline${i}`} style={{\n                    top: `${minTop - clientTop + pos[1]}px`,\n                    left: `${-targetLeft + pos[0]}px`,\n                    height: `${size}px`,\n                }} />;\n            }),\n            ...horizontalGuidelines.map((guideline, i) => {\n                const { pos, size, element } = guideline;\n\n                return <div className={prefix(\n                    \"line\",\n                    \"horizontal\",\n                    \"guideline\",\n                    element ? \"bold\" : \"\",\n                )} key={`horizontalGuidline${i}`} style={{\n                    top: `${-targetTop + pos[1]}px`,\n                    left: `${minLeft - clientLeft + pos[0]}px`,\n                    width: `${size}px`,\n                }} />;\n            }),\n        ];\n    },\n    dragStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = {\n            snap: true,\n            center: true,\n        };\n        snapStart(moveable);\n    },\n    pinchStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragControlCondition(target: HTMLElement | SVGElement) {\n        return directionCondition(target) || rotatableDragControlCondtion(target);\n    },\n    dragControlStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragControlEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroupEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(moveable: any, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragGroupControlEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n    },\n};\n","import { getDragDist, setDragStart } from \"../DraggerUtils\";\nimport { throttleArray, triggerEvent, fillParams, throttle, getDistSize, prefix } from \"../utils\";\nimport { minus, plus, getRad } from \"@moveable/matrix\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState, Renderer,\n} from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport { checkSnapDrag, startCheckSnapDrag } from \"./Snappable\";\nimport { TINY_NUM } from \"../consts\";\n\nexport default {\n    name: \"draggable\",\n    props: {\n        draggable: Boolean,\n        throttleDrag: Number,\n        throttleDragRotate: Number,\n    },\n    render(\n        moveable: MoveableManager<DraggableProps, DraggableState>,\n        React: Renderer,\n    ) {\n        const throttleDragRotate = moveable.props.throttleDragRotate;\n        const { dragInfo, beforeOrigin } = moveable.state;\n\n        if (!throttleDragRotate || !dragInfo) {\n            return;\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return;\n        }\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return <div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad)`,\n        }} />;\n    },\n    dragStart(\n        moveable: MoveableManager<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentDragger } = e;\n        const state = moveable.state;\n        const {\n            targetTransform,\n            target,\n            dragger,\n        } = state;\n\n        if (dragger) {\n            return false;\n        }\n        state.dragger = parentDragger || moveable.targetDragger;\n        const style = window.getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.transform = targetTransform;\n        datas.startTranslate = [0, 0];\n\n        setDragStart(moveable, { datas });\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n\n        startCheckSnapDrag(moveable, datas);\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startTranslate = translate;\n            },\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            state.dragger = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManager<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        const { datas, parentEvent, parentFlag } = e;\n        let { distX, distY } = e;\n        const { isPinch, isDrag, prevDist, prevBeforeDist, transform, startTranslate } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let isSnap = false;\n        let dragRotateRad = 0;\n\n        if (throttleDragRotate > 0 && distX && distY) {\n            const deg = throttle(getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate);\n            const r = getDistSize([distX, distY]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag && distX && distY) {\n            const [verticalInfo, horizontalInfo] = checkSnapDrag(moveable, distX, distY, datas);\n            const {\n                isSnap: isVerticalSnap,\n                isBound: isVerticalBound,\n                offset: verticalOffset,\n            } = verticalInfo;\n            const {\n                isSnap: isHorizontalSnap,\n                isBound: isHorizontalBound,\n                offset: horizontalOffset,\n            } = horizontalInfo;\n            isSnap = isVerticalSnap || isHorizontalSnap;\n\n            if (throttleDragRotate) {\n                const adjustPoses = [];\n                if (isVerticalBound && isHorizontalBound) {\n                    adjustPoses.push(\n                        [0, horizontalOffset],\n                        [verticalOffset, 0],\n                    );\n                } else if (isVerticalBound) {\n                    adjustPoses.push(\n                        [verticalOffset, 0],\n                    );\n                } else if (isHorizontalBound) {\n                    adjustPoses.push(\n                        [0, horizontalOffset],\n                    );\n                } else if (isVerticalSnap && isHorizontalSnap) {\n                    adjustPoses.push(\n                        [0, horizontalOffset],\n                        [verticalOffset, 0],\n                    );\n                } else if (isVerticalSnap) {\n                    adjustPoses.push(\n                        [verticalOffset, 0],\n                    );\n                } else if (isHorizontalSnap) {\n                    adjustPoses.push(\n                        [0, horizontalOffset],\n                    );\n                }\n                if (adjustPoses.length) {\n                    adjustPoses.sort((a, b) => {\n                        return getDistSize(minus([distX, distY], a)) - getDistSize(minus([distX, distY], b));\n                    });\n                    const adjustPos = adjustPoses[0];\n                    if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n                        const prevDistX = distX;\n                        distX -= adjustPos[0];\n                        distY = distY * Math.abs(distX) / Math.abs(prevDistX);\n                    } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n                        const prevDistY = distY;\n                        distY -= adjustPos[1];\n                        distX = distX * Math.abs(distY) / Math.abs(prevDistY);\n                    }\n                }\n            } else {\n                distX -= verticalOffset;\n                distY -= horizontalOffset;\n            }\n        }\n        datas.passDistX = distX;\n        datas.passDistY = distY;\n        const beforeTranslate = plus(getDragDist({ datas, distX, distY }, true), startTranslate);\n        const translate = plus(getDragDist({ datas, distX, distY }, false), startTranslate);\n\n        if (!throttleDragRotate && !isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n\n        const beforeDist = minus(beforeTranslate, startTranslate);\n        const dist = minus(translate, startTranslate);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = `${transform} translate(${dist[0]}px, ${dist[1]}px)`;\n\n        moveable.state.dragInfo.dist = dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            isPinch,\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragEnd(\n        moveable: MoveableManager<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas, isDrag } = e;\n\n        moveable.state.dragger = null;\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", fillParams<OnDragEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        const datas = e.datas;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildAble(moveable, this, \"dragStart\", datas, e);\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        const datas = e.datas;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDistX, passDistY } = e.datas;\n        const events = triggerChildAble(moveable, this, \"drag\", datas, { ...e, distX: passDistX, distY: passDistY });\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragEnd\", datas, e);\n        triggerEvent(moveable, \"onDragGroupEnd\", fillParams(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        }));\n\n        return isDrag;\n    },\n    unset(moveable: any) {\n        moveable.state.dragInfo = null;\n    },\n};\n","import { MoveableManagerState, OnCustomDrag } from \"./types\";\n\nexport function setCustomDrag(state: Partial<MoveableManagerState<any>>, delta: number[], inputEvent: any) {\n    return {\n        ...state.dragger!.move(delta, inputEvent),\n        parentEvent: true,\n    };\n}\n\nexport default class CustomDragger {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas = {};\n\n    public dragStart(client: number[], inputEvent: any)  {\n        this.isDrag = false;\n        this.isFlag = false;\n        this.datas = {};\n\n        return this.move(client, inputEvent);\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n            this.isDrag = true;\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas,\n            parentEvent: true,\n            parentDragger: this,\n        };\n    }\n}\n","import { throttle, prefix, triggerEvent, fillParams, getRotationRad, getClientRect } from \"../utils\";\nimport { IObject, hasClass } from \"@daybrush/utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate,\n    OnRotateEnd, MoveableClientRect, SnappableProps, SnappableState,\n} from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { minus, plus, getRad, rotate as rotateMatrix } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapRotate } from \"./Snappable\";\n\nfunction setRotateStartInfo(\n    datas: IObject<any>, clientX: number, clientY: number, origin: number[], rect: MoveableClientRect) {\n    datas.startAbsoluteOrigin = [\n        rect.left + origin[0],\n        rect.top + origin[1],\n    ];\n\n    datas.prevDeg = getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.startDeg = datas.prevDeg;\n    datas.loop = 0;\n}\nfunction getDeg(\n    moveable: MoveableManager<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    deg: number,\n    direction: number,\n    startRotate: number,\n    throttleRotate: number,\n    isSnap?: boolean,\n) {\n    const {\n        prevDeg,\n        startDeg,\n        loop: prevLoop,\n    } = datas;\n\n    if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++datas.loop;\n    } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --datas.loop;\n    }\n    const loop = datas.loop;\n    const absolutePrevDeg = prevLoop * 360 + prevDeg - startDeg + startRotate;\n    let absoluteDeg = loop * 360 + deg - startDeg + startRotate;\n\n    absoluteDeg = throttle(absoluteDeg, throttleRotate);\n\n    let dist = direction * (absoluteDeg - startRotate);\n    if (isSnap) {\n        dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);\n        absoluteDeg = dist / direction + startRotate;\n    }\n    const delta = direction * (absoluteDeg - absolutePrevDeg);\n\n    datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    return [delta, dist, absoluteDeg];\n}\nfunction getRotateInfo(\n    moveable: MoveableManager<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    direction: number,\n    clientX: number, clientY: number,\n    startRotate: number,\n    throttleRotate: number,\n) {\n    return getDeg(\n        moveable,\n        moveableRect,\n        datas,\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        startRotate,\n        throttleRotate,\n        true,\n    );\n}\n\nexport function getPositions(\n    rotationPosition: \"top\" | \"bottom\" | \"left\" | \"right\",\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n) {\n    if (rotationPosition === \"left\") {\n        return [pos3, pos1];\n    } else if (rotationPosition === \"right\") {\n        return [pos2, pos4];\n    } else if (rotationPosition === \"bottom\") {\n        return [pos4, pos3];\n    }\n    return [pos1, pos2];\n}\n\nexport function dragControlCondition(target: HTMLElement | SVGElement) {\n    return hasClass(target, prefix(\"rotation\"));\n}\n\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n    props: {\n        rotatable: Boolean,\n        rotationPosition: String,\n        throttleRotate: Number,\n    },\n    render(moveable: MoveableManager<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n        } = moveable.props;\n        if (!rotatable) {\n            return null;\n        }\n        const { pos1, pos2, pos3, pos4, direction } = moveable.state;\n        const poses = getPositions(rotationPosition!, pos1, pos2, pos3, pos4);\n        const rotationRad = getRotationRad(poses, direction);\n\n        return (\n            <div key=\"rotation\" className={prefix(\"line rotation-line\")} style={{\n                // tslint:disable-next-line: max-line-length\n                transform: `translate(${(poses[0][0] + poses[1][0]) / 2}px, ${(poses[0][1] + poses[1][1]) / 2}px) rotate(${rotationRad}rad)`,\n            }}>\n                <div className={prefix(\"control\", \"rotation\")}></div>\n            </div>\n        );\n    },\n    dragControlCondition,\n    dragControlStart(\n        moveable: MoveableManager<RotatableProps & SnappableProps, SnappableState>,\n        e: any) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, pinchFlag } = e;\n        const {\n            target, left, top, origin, beforeOrigin,\n            direction, beforeDirection, targetTransform,\n        } = moveable.state;\n\n        if (!target) {\n            return false;\n        }\n        datas.rect = moveable.getRect();\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n\n        if (pinchFlag || parentFlag) {\n            datas.beforeInfo = { prevDeg: parentRotate, startDeg: parentRotate, loop: 0 };\n            datas.afterInfo = { prevDeg: parentRotate, startDeg: parentRotate, loop: 0 };\n        } else {\n            datas.beforeInfo = { origin: plus([left, top], beforeOrigin) };\n            datas.afterInfo = { origin: plus([left, top], origin) };\n\n            const rect = getClientRect(moveable.controlBox.getElement());\n            setRotateStartInfo(datas.afterInfo, clientX, clientY, origin, rect);\n            setRotateStartInfo(datas.beforeInfo, clientX, clientY, beforeOrigin, rect);\n        }\n\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startRotate = 0;\n        datas.datas = {};\n\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startRotate = rotatation;\n            },\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        moveable.state.snapRenderInfo = {};\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<RotatableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, pinchFlag } = e;\n        const {\n            direction,\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            isRotate,\n            startRotate,\n            rect,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n        const {\n            throttleRotate = 0,\n            parentMoveable,\n        } = moveable.props;\n\n        let delta: number;\n        let dist: number;\n        let rotate: number;\n        let beforeDelta: number;\n        let beforeDist: number;\n        let beforeRotate: number;\n\n        if (pinchFlag || parentFlag) {\n            [delta, dist, rotate]\n                = getDeg(moveable, rect, afterInfo, parentRotate, direction, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getDeg(moveable, rect, beforeInfo, parentRotate, direction, startRotate, throttleRotate);\n        } else {\n            [delta, dist, rotate]\n                = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate] = getRotateInfo(\n                moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate,\n            );\n        }\n\n        if (!delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate,\n            beforeDist,\n            beforeDelta,\n            beforeRotate,\n            transform: `${datas.transform} rotate(${dist}deg)`,\n            isPinch: !!pinchFlag,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<RotatableProps>, e: any) {\n        const { datas, isDrag } = e;\n\n        if (!datas.isRotate) {\n            return false;\n        }\n        datas.isRotate = false;\n\n        triggerEvent(moveable, \"onRotateEnd\", fillParams<OnRotateEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: dragControlCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas, inputEvent } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        params.set(moveable.rotation);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            { ...e, parentRotate: 0 },\n            (child, childDatas, eventParams) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                childDatas.prevClient = childClient;\n                eventParams.dragStart = Draggable.dragStart(\n                    child,\n                    new CustomDragger().dragStart(childClient, inputEvent),\n                );\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { inputEvent, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            { ...e, parentRotate },\n            (child, childDatas, result, i) => {\n                const [prevX, prevY] = childDatas.prevClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                childDatas.prevClient = [clientX, clientY];\n\n                const dragResult = Draggable.drag(\n                    child,\n                    setCustomDrag(child.state, delta, inputEvent),\n                );\n\n                result.drag = dragResult;\n            },\n        );\n        moveable.rotation = params.beforeRotate;\n\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            set: (rotation: number) => {\n                moveable.rotation = rotation;\n            },\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnRotateGroupEnd = fillParams(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { prefix, getControlTransform, throttle } from \"./utils\";\nimport { ResizableProps, ScalableProps, WarpableProps, Renderer } from \"./types\";\nimport { DIRECTION_INDEXES, DIRECTION_ROTATIONS } from \"./consts\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function renderControls(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    defaultDirections: string[],\n    React: Renderer,\n): any[] {\n    const {\n        pos1, pos2, pos3, pos4,\n        rotation,\n    } = moveable.state;\n    const {\n        renderDirections: directions = defaultDirections,\n    } = moveable.props;\n    const poses = [pos1, pos2, pos3, pos4];\n\n    const directionMap: IObject<boolean> = {};\n    directions.forEach(direction => {\n        directionMap[direction] = true;\n    });\n    return directions.map(direction => {\n        const indexes = DIRECTION_INDEXES[direction];\n\n        if (!indexes || !directionMap[direction]) {\n            return null;\n        }\n        const directionRotation = (throttle(rotation / Math.PI * 180, 15) + DIRECTION_ROTATIONS[direction]) % 180;\n\n        return (\n            <div className={prefix(\"control\", \"direction\", direction)}\n                data-rotation={directionRotation} data-direction={direction} key={`direction-${direction}`}\n                style={getControlTransform(rotation, ...indexes.map(index => poses[index]))}></div>\n        );\n    });\n}\nexport function renderAllDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n) {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\", \"n\", \"w\", \"s\", \"e\"], React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n): any[] {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n","import {\n    throttle, getDirection, triggerEvent,\n    getAbsolutePosesByState, fillParams, getKeepRatioHeight, getKeepRatioWidth, getCSSSize, getDistSize,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getDragDist,\n    getResizeDist,\n    getPosByReverseDirection,\n    getFixedPosition,\n    getStartDirection,\n} from \"../DraggerUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    Renderer, OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd,\n} from \"../types\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport {\n    triggerChildAble, directionCondition,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapSize } from \"./Snappable\";\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    updateRect: true,\n    canPinch: true,\n    props: {\n        resizable: Boolean,\n        throttleResize: Number,\n        renderDirections: Array,\n        baseDirection: Array,\n        keepRatio: Boolean,\n    },\n    render(moveable: MoveableManager<Partial<ResizableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, edge } = moveable.props;\n        if (resizable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            pinchFlag,\n            datas,\n        } = e;\n        const {\n            target: inputTarget,\n        } = inputEvent;\n\n        const direction = pinchFlag ? [1, 1] : getDirection(inputTarget);\n        const { target, width, height } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        !pinchFlag && setDragStart(moveable, { datas });\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n        [\n            datas.startWidth,\n            datas.startHeight,\n        ] = getCSSSize(target);\n        datas.transformOrigin = moveable.props.transformOrigin;\n        datas.startDirection = getStartDirection(moveable, direction);\n        datas.fixedPosition = getFixedPosition(moveable, datas.startDirection);\n        datas.fixedOriginalPosition = getFixedPosition(moveable, direction);\n\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ),\n        });\n        const result = triggerEvent(moveable, \"onResizeStart\", params);\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                direction,\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            distX, distY,\n            parentFlag, pinchFlag,\n            parentDistance, parentScale, inputEvent,\n            parentKeepRatio,\n            dragClient,\n        } = e;\n        const {\n            direction,\n            isResize,\n            transformOrigin,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            startWidth,\n            startHeight,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n        const {\n            throttleResize = 0,\n            parentMoveable,\n        } = moveable.props;\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const isWidth = direction[0] || !direction[1];\n        const ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;\n        let distWidth: number = 0;\n        let distHeight: number = 0;\n\n        if (parentScale) {\n            distWidth = (parentScale[0] - 1) * startOffsetWidth;\n            distHeight = (parentScale[1] - 1) * startOffsetHeight;\n\n        } else if (pinchFlag) {\n            if (parentDistance) {\n                distWidth = parentDistance;\n                distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n\n            distWidth = direction[0] * dist[0];\n            distHeight = direction[1] * dist[1];\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], direction);\n                const ratioRad = getRad([0, 0], [startOffsetWidth, startOffsetHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!direction[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!direction[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n        }\n        let nextWidth = direction[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, 0) : startOffsetWidth;\n        let nextHeight = direction[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, 0) : startOffsetHeight;\n\n        let snapDist = [0, 0];\n\n        if (!pinchFlag) {\n            snapDist = checkSnapSize(moveable, nextWidth, nextHeight, direction, datas);\n        }\n        if (keepRatio) {\n            if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nextWidth = throttle(nextWidth, throttleResize!);\n                } else {\n                    nextHeight = throttle(nextHeight, throttleResize!);\n                }\n            }\n            if (\n                (direction[0] && !direction[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nextWidth += snapDist[0];\n                nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);\n            } else if (\n                (!direction[0] && direction[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nextHeight += snapDist[1];\n                nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);\n            }\n        } else {\n            nextWidth += snapDist[0];\n            nextHeight += snapDist[1];\n            if (!snapDist[0]) {\n                nextWidth = throttle(nextWidth, throttleResize!);\n            }\n            if (!snapDist[1]) {\n                nextHeight = throttle(nextHeight, throttleResize!);\n            }\n        }\n        nextWidth = Math.round(nextWidth);\n        nextHeight = Math.round(nextHeight);\n\n        distWidth = nextWidth - startOffsetWidth;\n        distHeight = nextHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        if (!parentMoveable && delta.every(num => !num)) {\n            return;\n        }\n\n        const startDirection = keepRatio || parentFlag ? direction : datas.startDirection;\n        const fixedPosition = dragClient || (keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition);\n\n        const inverseDelta = !parentFlag && pinchFlag\n            ? [0, 0]\n            : getResizeDist(\n                moveable,\n                nextWidth, nextHeight,\n                startDirection, fixedPosition, transformOrigin);\n\n        const params = fillParams<OnResize>(moveable, e, {\n            width: startWidth + distWidth,\n            height: startHeight + distHeight,\n            offsetWidth: nextWidth,\n            offsetHeight: nextHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!pinchFlag,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            this.dragControl(moveable, e);\n            return true;\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isResize) {\n            return false;\n        }\n        datas.isResize = false;\n\n        const params = fillParams<OnResizeEnd>(moveable, e, {\n            isDrag,\n        });\n        triggerEvent(moveable, \"onResizeEnd\", params);\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const {\n            offsetWidth, offsetHeight, dist,\n        } = params;\n\n        const keepRatio = moveable.props.keepRatio;\n\n        const parentScale = [\n            offsetWidth / (offsetWidth - dist[0]),\n            offsetHeight / (offsetHeight - dist[1]),\n        ];\n        const fixedPosition = datas.fixedOriginalPosition;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * parentScale[0],\n                        childDatas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentScale,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                    parentKeepRatio: keepRatio,\n                };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnResizeGroupEnd = fillParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n};\n","import {\n    throttle, getDirection, triggerEvent, multiply2, getAbsolutePosesByState,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth, getDistSize,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport { setDragStart, getDragDist, getScaleDist, getPosByReverseDirection } from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport {\n    ScalableProps, ResizableProps, OnScaleGroup, OnScaleGroupEnd,\n    Renderer, OnScaleGroupStart, DraggableProps, OnDragStart,\n    OnDrag, SnappableState, GroupableProps, OnScaleStart, OnScale, OnScaleEnd,\n} from \"../types\";\nimport {\n    directionCondition, triggerChildAble,\n} from \"../groupUtils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapScale } from \"./Snappable\";\nimport { isArray } from \"@daybrush/utils\";\n\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        scalable: Boolean,\n        throttleScale: Number,\n        renderDirections: String,\n        keepRatio: Boolean,\n    },\n    render(moveable: MoveableManager<Partial<ResizableProps & ScalableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, scalable, edge } = moveable.props;\n        if (!resizable && scalable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n\n        const { datas, pinchFlag, inputEvent } = e;\n        const { target: inputTarget } = inputEvent;\n        const direction = pinchFlag ? [1, 1] : getDirection(inputTarget);\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!pinchFlag) {\n            setDragStart(moveable, { datas });\n        }\n\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.width = width;\n        datas.height = height;\n        datas.startScale = [1, 1];\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startScale = scale;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                direction,\n            };\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        const {\n            datas, distX, distY,\n            parentScale,\n            parentDistance,\n            parentKeepRatio,\n            parentFlag, pinchFlag, inputEvent,\n            dragClient,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            width,\n            height,\n            transform,\n            isScale,\n            startScale,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const {\n            throttleScale,\n            parentMoveable,\n        } = moveable.props;\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const state = moveable.state;\n        const isWidth = direction[0] || !direction[1];\n        let scaleX: number = 1;\n        let scaleY: number = 1;\n        const startWidth = width * startScale[0];\n        const startHeight = height * startScale[1];\n        const ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;\n\n        if (parentScale) {\n            scaleX = parentScale[0];\n            scaleY = parentScale[1];\n        } else if (pinchFlag) {\n            if (parentDistance) {\n                scaleX = (width + parentDistance) / width;\n                scaleY = (height + parentDistance * height / width) / height;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n            let distWidth = direction[0] * dist[0];\n            let distHeight = direction[1] * dist[1];\n\n            if (keepRatio && width && height) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], direction);\n                const ratioRad = getRad([0, 0], [startWidth, startHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!direction[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!direction[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n            scaleX = (width + distWidth) / width;\n            scaleY = (height + distHeight) / height;\n        }\n        scaleX = direction[0] ? scaleX * startScale[0] : startScale[0];\n        scaleY = direction[1] ? scaleY * startScale[1] : startScale[1];\n\n        if (scaleX === 0) {\n            scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (scaleY === 0) {\n            scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n\n        const nowDist = [scaleX / startScale[0], scaleY / startScale[1]];\n        let scale = [scaleX, scaleY];\n        let snapDirection = direction;\n\n        if (moveable.props.groupable) {\n            snapDirection = [\n                (nowDist[0] >= 0 ? 1 : -1) * direction[0],\n                (nowDist[1] >= 0 ? 1 : -1) * direction[1],\n            ];\n            const snapRenderInfo = state.snapRenderInfo || {};\n            const stateDirection = snapRenderInfo.direction;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = { direction };\n            }\n        }\n        let snapDist = [0, 0];\n\n        if (!pinchFlag) {\n            snapDist = checkSnapScale(moveable, nowDist, direction, snapDirection, datas);\n        }\n\n        if (keepRatio) {\n            if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n                } else {\n                    nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n                }\n            }\n\n            if (\n                (direction[0] && !direction[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nowDist[0] += snapDist[0];\n                const snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);\n\n                nowDist[1] = snapHeight / height / startScale[1];\n            } else if (\n                (!direction[0] && direction[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nowDist[1] += snapDist[1];\n                const snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);\n\n                nowDist[0] = snapWidth / width / startScale[0];\n            }\n        } else {\n            nowDist[0] += snapDist[0];\n            nowDist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n            }\n            if (!snapDist[1]) {\n                nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n            }\n        }\n        if (nowDist[0] === 0) {\n            nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (nowDist[1] === 0) {\n            nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];\n        scale = multiply2(nowDist, startScale);\n\n        datas.prevDist = nowDist;\n\n        if (scaleX === prevDist[0] && scaleY === prevDist[1] && !parentMoveable) {\n            return false;\n        }\n        const inverseDelta = !parentFlag && pinchFlag\n            ? [0, 0]\n            : getScaleDist(moveable, delta, direction, dragClient);\n\n        const params = fillParams<OnScale>(moveable, e, {\n            scale,\n            direction,\n            dist: nowDist,\n            delta,\n            transform: `${transform} scale(${scaleX}, ${scaleY})`,\n            isPinch: !!pinchFlag,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillParams<OnScaleEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n        const keepRatio = moveable.props.keepRatio;\n        const { scale, direction, dist } = params;\n        const prevPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), multiply2(direction, dist));\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * scale[0],\n                        childDatas.originalY * scale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentScale: scale,\n                    parentKeepRatio: keepRatio,\n                    dragClient: plus(prevPos, [clientX, clientY]),\n                };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams = fillParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n};\n","import { prefix, getLineStyle, getDirection, getAbsolutePosesByState, triggerEvent, fillParams } from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    convertMatrixtoCSS, caculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    multiplyCSS,\n    minus,\n    createWarpMatrix,\n    getRad,\n    plus,\n} from \"@moveable/matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport { setDragStart, getDragDist, getPosIndexesByDirection } from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd,\n} from \"../types\";\nimport { hasClass, dot } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirection\";\nimport { checkSnapPoses, hasGuidelines, getNearestSnapGuidelineInfo } from \"./Snappable\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: {\n        warpable: Boolean,\n        renderDirections: Array,\n    },\n    render(moveable: MoveableManager<ResizableProps & ScalableProps & WarpableProps>, React: Renderer) {\n        const { resizable, scalable, warpable } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return;\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")} key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4)}></div>,\n            ...renderAllDirections(moveable, React),\n        ];\n    },\n    dragControlCondition(target: HTMLElement | SVGElement) {\n        return hasClass(target, prefix(\"direction\"));\n    },\n    dragControlStart(\n        moveable: MoveableManager<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n\n        setDragStart(moveable, { datas });\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map((p, i) => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startMatrix = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n        state.snapRenderInfo = {\n            direction,\n        };\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startMatrix = matrix;\n            },\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl(\n        moveable: MoveableManager<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startMatrix,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkSnapPoses(\n                moveable,\n                selectedPoses.map(pos => pos[0] + distX),\n                selectedPoses.map(pos => pos[1] + distY),\n            );\n\n            distY -= getNearestSnapGuidelineInfo(horizontalSnapInfo).offset;\n            distX -= getNearestSnapGuidelineInfo(verticalSnapInfo).offset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[1],\n            poses[2],\n            poses[3],\n            nextPoses[0],\n            nextPoses[1],\n            nextPoses[2],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n\n        const matrix = convertMatrixtoCSS(multiply(targetInverseMatrix, h, 4));\n        const transform = `${datas.targetTransform} matrix3d(${matrix.join(\",\")})`;\n\n        const delta = multiplyCSS(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: multiplyCSS(startMatrix, matrix, 4),\n            multiply: multiplyCSS,\n            dist: matrix,\n            transform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManager<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillParams<OnWarpEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n};\n","import { prefix } from \"./utils\";\n\nexport const AREA = prefix(\"area\");\nexport const AREA_PIECES = prefix(\"area-pieces\");\nexport const AREA_PIECE = prefix(\"area-piece\");\nexport const AVOID = prefix(\"avoid\");\n","import MoveableManager from \"../MoveableManager\";\nimport { createWarpMatrix, convertMatrixtoCSS } from \"@moveable/matrix\";\nimport { ref } from \"framework-utils\";\nimport { triggerEvent, fillParams, getRect } from \"../utils\";\nimport { Renderer, GroupableProps, DragAreaProps, OnClick } from \"../types\";\nimport { AREA_PIECE, AREA, AVOID, AREA_PIECES } from \"../classNames\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { addClass, findIndex, removeClass } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManager) {\n    const el = moveable.areaElement;\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    props: {\n        dragArea: Boolean,\n    },\n    render(moveable: MoveableManager<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable } = moveable.props;\n        const { width, height, pos1, pos2, pos3, pos4 } = moveable.state;\n\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        );\n        const transform = h.length ? `matrix3d(${convertMatrixtoCSS(h).join(\",\")})` : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManager, { datas, clientX, clientY, inputEvent }: any) {\n        datas.isDragArea = false;\n        datas.inputTarget = inputEvent.target;\n        const areaElement = moveable.areaElement;\n        const {\n            targetClientRect,\n            pos1, pos2, pos3, pos4,\n        } = moveable.state;\n        const { left, top, width, height } = targetClientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n        } = getRect([pos1, pos2, pos3, pos4]);\n        const posX = clientX - left;\n        const posY = clientY - top;\n\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n    },\n    drag(moveable: MoveableManager, { datas }: any) {\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManager<DragAreaProps>, e: any) {\n        const { inputEvent, isDragArea, datas } = e;\n        if (!datas.isDragArea) {\n            restoreStyle(moveable);\n        }\n\n        const target = moveable.state.target!;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget)) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroup,\n        e: any,\n    ) {\n        const { inputEvent, isDragArea, datas } = e;\n\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n        const prevInputTarget = datas.inputTarget;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { prefix, getControlTransform } from \"../utils\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"origin\",\n    props: {\n        origin: Boolean,\n    },\n    render(moveable: MoveableManager, React: Renderer): any {\n        if (!moveable.props.origin) {\n            return null;\n        }\n        const { beforeOrigin, rotation } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { ScrollableProps, OnScroll } from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: {\n        scrollable: Boolean,\n        scrollContainer: Object,\n        scrollThreshold: Number,\n    },\n    dragStart(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer(),\n        } = props;\n\n        const dragScroll = new DragScroll();\n\n        e.datas.dragScroll = dragScroll;\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY }) => {\n            moveable.targetDragger.scrollBy(offsetX, offsetY, e.inputEvent, false);\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainer as HTMLElement,\n        });\n    },\n    checkScroll(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const {\n            dragScroll,\n        } = e.datas;\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer(),\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer,\n            threshold: scrollThreshold,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManager<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManager<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        return this.drag(moveable, {...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        this.dragEnd(moveable, e);\n    },\n};\n","export default {\n    name: \"\",\n    props: {\n        target: Object,\n        container: Object,\n        dragArea: Boolean,\n        origin: Boolean,\n        transformOrigin: Array,\n        edge: Boolean,\n        ables: Array,\n        className: String,\n        pinchThreshold: Number,\n    },\n};\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\n\nexport const MOVEABLE_ABLES = [\n    Default, Snappable, Pinchable, Draggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, DragArea, Origin,\n] as const;\n","import { refs } from \"framework-utils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    props: {\n        defaultGroupRotate: Number,\n        groupable: Boolean,\n    },\n    render(moveable: MoveableGroup, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n\n        return targets.map((target, i) => {\n            return <MoveableManager\n                key={\"moveable\" + i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        });\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, MoveableManagerProps } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleDragger } from \"./getAbleDragger\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getTargetInfo, throttle, getAbsolutePosesByState, equals } from \"./utils\";\nimport { plus, rotate } from \"@moveable/matrix\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = rotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1s = [MIN_NUM, MAX_NUM];\n        const b2s = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                // ㅠ = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1s[0] = Math.max(b1s[0], b1);\n                b1s[1] = Math.min(b1s[1], b1);\n                b2s[0] = Math.max(b2s[0], b2);\n                b2s[1] = Math.min(b2s[1], b2);\n            });\n        });\n\n        b1s.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2s.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n\nclass MoveableGroup extends MoveableManager<GroupableProps, any> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public rotation: number = 0;\n\n    public updateEvent(prevProps: MoveableManagerProps<GroupableProps>) {\n        const state = this.state;\n        const props = this.props;\n\n        if (!state.target) {\n            state.target = this.areaElement;\n\n            this.controlBox.getElement().style.display = \"block\";\n            this.targetDragger = getAbleDragger(this, state.target!, \"targetAbles\", \"Group\");\n            this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n        }\n        const isContainerChanged = !equals(prevProps.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const props = this.props;\n        const target = state.target! || props.target!;\n\n        if (!isTarget || (type !== \"\" && props.updateGroup)) {\n            // reset rotataion\n            this.rotation = props.defaultGroupRotate!;\n        }\n        const rotation = this.rotation;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        target.style.cssText += `left:0px;top:0px;width:${width}px; height:${height}px;transform:rotate(${rotation}deg)`;\n        state.width = width;\n        state.height = height;\n\n        const info = getTargetInfo(target, this.controlBox.getElement(), this.getContainer(), state);\n        const pos = [info.left!, info.top!];\n        [\n            info.pos1,\n            info.pos2,\n            info.pos3,\n            info.pos4,\n        ] = getAbsolutePosesByState(info as Required<typeof info>);\n        info.origin = plus(pos, info.origin!);\n        info.beforeOrigin = plus(pos, info.beforeOrigin!);\n\n        const clientRect = info.targetClientRect!;\n\n        clientRect.top += (top - info.top!) - state.top;\n        clientRect.left += (left - info.left!) - state.left;\n\n        this.updateState(\n            {\n                ...info,\n                left: left - info.left!,\n                top: top - info.top!,\n            },\n            isSetState,\n        );\n    }\n    public triggerEvent(name: string, e: any): any {\n        if (name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n}\n\nexport default MoveableGroup;\n","import * as React from \"react\";\nimport { MoveableProps, Able, MoveableInterface, RectInfo } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref } from \"framework-utils\";\nimport { isArray } from \"@daybrush/utils\";\nimport Groupable from \"./ables/Groupable\";\n\nexport default class Moveable<T = {}> extends React.PureComponent<MoveableProps & T> implements MoveableInterface {\n    public moveable!: MoveableManager<MoveableProps> | MoveableGroup;\n    public render() {\n        const props = this.props;\n        const ables: Able[] = props.ables as Able[] || [];\n        const target = this.props.target || this.props.targets;\n        const isArr = isArray(target);\n        const isGroup = isArr && (target as any[]).length > 1;\n\n        if (isGroup) {\n            const nextProps = {\n                ...this.props,\n                target: null,\n                targets: target as any[],\n                ables: [...MOVEABLE_ABLES, Groupable, ...ables],\n            };\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps} />;\n        } else {\n            const moveableTarget = isArr ? (target as any[])[0] : target;\n\n            return <MoveableManager<MoveableProps> key=\"single\" ref={ref(this, \"moveable\")}\n                {...{ ...this.props, target: moveableTarget, ables: [...MOVEABLE_ABLES, ...ables] }} />;\n        }\n    }\n    public isMoveableElement(target: HTMLElement) {\n        return this.moveable.isMoveableElement(target);\n    }\n    public dragStart(e: MouseEvent | TouchEvent) {\n        this.moveable.dragStart(e);\n    }\n    public isInside(clientX: number, clientY: number) {\n        return this.moveable.isInside(clientX, clientY);\n    }\n    public updateRect() {\n        this.moveable.updateRect();\n    }\n    public updateTarget() {\n        this.moveable.updateTarget();\n    }\n    public getRect(): RectInfo {\n        return this.moveable.getRect();\n    }\n    public destroy() {\n        this.moveable.componentWillUnmount();\n    }\n}\n"],"names":["getSVGCursor","scale","degree","getCursorCSS","x1","x2","degree45","Math","round","defaultCursor","agent","getAgent","isWebkit","os","name","indexOf","browser","PREFIX","MOVEABLE_CSS","prefixCSS","map","join","NEARBY_POS","TINY_NUM","MIN_SCALE","MAX_NUM","pow","MIN_NUM","DIRECTION_INDEXES","n","s","w","e","nw","ne","sw","se","DIRECTION_ROTATIONS","multiply2","pos1","pos2","prefix","_i","classNames","prefixNames","createIdentityMatrix3","createIdentityMatrix","getTransformMatrix","transform","isObject","value","splitBracket","split","v","parseFloat","getAbsoluteMatrix","matrix","origin","multiplies","createOriginMatrix","a","measureSVGSize","el","unit","isHorizontal","viewBox","ownerSVGElement","baseVal","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","o","i","_a","style","transformOrigin","getOffsetInfo","lastParent","isParent","body","document","target","parentElement","isEnd","position","isStatic","offsetParent","caculateMatrixStack","container","prevMatrix","prevN","matrixes","isSVGGraphicElement","tagName","toLowerCase","originalContainer","is3d","targetMatrix","offsetContainer","isFixed","styleTransform","convertCSStoMatrix","length","matrixesLength","convertDimension","offsetLeft","offsetTop","containerClientRect","documentElement","getBoundingClientRect","left","top","isSVG","isUndefined","hasNotOffset","pos","push","getSVGMatrix","_b","isOffsetEnd","parentClientLeft","parentClientTop","clientLeft","clientTop","scrollLeft","scrollTop","mat","beforeMatrix","offsetMatrix","endContainer","reverse","forEach","slice","multiply","isMatrix3d","convertMatrixtoCSS","clientWidth","clientHeight","viewBoxWidth","width","viewBoxHeight","height","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","translate","xAlign","yAlign","floor","scaleDimension","max","min","scaleMatrix","createScaleMatrix","getSVGGraphicsOffset","getBBox","bbox","svgElement","x","y","caculatePosition","caculate","convertPositionMatrix","caculatePoses","pos3","pos4","getRect","poses","posesX","posesY","right","bottom","rectWidth","rectHeight","caculateRect","getSVGOffset","absoluteMatrix","rect","rectLeft","rectTop","_c","prevLeft","prevTop","prevWidth","prevHeight","posOrigin","prevOrigin","minus","rectOrigin","offset","count","inverseBeforeMatrix","invert","mat2","_d","nextLeft","nextTop","distLeft","distTop","abs","p","caculateMoveablePosition","y1","y2","x3","y3","_e","x4","y4","_f","originX","originY","center","pos1Rad","getRad","pos2Rad","direction","PI","getDistSize","vec","sqrt","getDiagonalSize","getLineStyle","rad","getControlTransform","rotation","reduce","prev","getCSSSize","window","getSize","isOffset","isBoxSizing","boxSizing","offsetWidth","offsetHeight","hasOffset","borderLeft","borderLeftWidth","borderRight","borderRightWidth","borderTop","borderTopWidth","borderBottom","borderBottomWidth","paddingLeft","paddingRight","paddingTop","paddingBottom","getRotationRad","getTargetInfo","parentContainer","state","beforeDirection","targetTransform","beforeOrigin","targetClientRect","resetClientRect","undefined","beforePos","getClientRect","getDirection","direciton","getAttribute","dir","getAbsolutePoses","dist","plus","getAbsolutePosesByState","roundSign","num","throttle","throttleArray","nums","_","unset","self","getOrientationDirection","isInside","k1","k2","k3","k4","k5","k6","signs1","signs2","every","sign","fillParams","moveable","params","datas","tslib_1","clientX","clientY","inputEvent","currentTarget","triggerEvent","pseudoElt","filterAbles","ables","methods","enabledAbles","ableGroups","filter","able","some","method","ableGroup","getKeepRatioHeight","isWidth","ratio","getKeepRatioWidth","equals","a1","a2","selectValue","values","groupBy","arr","func","group","groupMap","index","groupKey","flat","cur","concat","triggerRenderStart","isGroup","isPinch","eventAffix","targets","props","triggerRender","triggerRenderEnd","sPinch","isDrag","triggerAble","ableType","eventOperation","eventType","isStart","areaElement","eventName","conditionName","isAfter","updateRect","events","results","condition","isUpdate","dragger","moveables","childeMoveable","forceUpdate","getAbleDragger","options","pinchThreshold","Dragger","ControlBoxElement","styled","renderLine","React","key","className","_this","conatainer","edge","parentPosition","propsTarget","checkUpdate","parentLeft","parentTop","stateTarget","groupTargets","isDisplay","ref","display","renderAbles","controlBox","getElement","parentMoveable","updateEvent","prevProps","getContainer","targetDragger","onDragStart","type","isTarget","isSetState","updateState","controlBoxElement","hasTargetAble","targetAbles","hasControlAble","controlAbles","prevTarget","dragArea","prevDragArea","isTargetChanged","isUnset","controlDragger","unsetAbles","stateContainer","updateAbles","isChanged","callback","dragStart","pinchStart","dragControlStart","nextState","setState","Renderer","createElement","render","MoveableManager","getRotatiion","touches","pinchable","Boolean","Number","controlEventName","pinchAbles","canPinch","result","parentRotate","ableEvent","pinchFlag","snapRenderInfo","pinch","pinchScale","distance","parentDistance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","triggerChildAble","eachEvent","ableDatas","match","childs","child","childDatas","childEvent","isFunction","parentFlag","directionCondition","hasClass","setDragStart","inverseMatrix","absoluteOrigin","startDragBeforeDist","startDragDist","getDragDist","isBefore","distX","distY","caculateTransformOrigin","prevSize","size","isNaN","measureRatio","getPosIndexesByDirection","indexes","getPosesByDirection","getPosByDirection","nextPoses","average","getPosByReverseDirection","getStartPos","startPos1","startPos2","startPos3","startPos4","getDist","startPos","getNextMatrix","getScaleDist","dragClient","groupable","nextMatrix","groupLeft","groupTop","getResizeDist","fixedPosition","nextOrigin","getStartDirection","baseDirection","getFixedPosition","snapStart","guidelines","horizontalGuidelines","verticalGuidelines","elementGuidelines","bounds","snapCenter","containerTop","containerLeft","targetLeft","targetTop","elementTop","elementBottom","elementLeft","elementRight","element","enableSnap","checkBounds","verticalPoses","horizontalPoses","snapThreshold","vertical","checkBound","horizontal","isVertical","endPos","minPos","maxPos","isBound","checkSnap","targetType","targetPoses","snapElement","isSnap","posInfos","posType","snapPosInfos","targetPos","guidelineInfos","guideline","sort","b","snapPosInfo","hasGuidelines","ableName","snappable","checkSnapPoses","customSnapThreshold","containerHeight","containerWidth","snapHorizontal","snapVertical","totalGuidelines","checkSnaps","isCenter","isSnapCenter","verticalNames","horizontalNames","checkBoundOneWayDist","isHorizontalBound","horizontalBoundOffset","isVerticalBound","verticalBoundOffset","solveNextDist","isDirectionVertical","sizeOffset","solveEquation","NaN","widthDist","heightDist","getFixedPoses","fixedPos","nextPos","getNearestSnapGuidelineInfo","snapInfo","posInfo","guidelineInfo","checkSnapOneWayPos","reversePos","horizontalSnapInfo","verticalSnapInfo","fixedHorizontal","fixedVertical","isHorizontalSnap","horizontalDist","horizontalOffset","isVerticalSnap","verticalDist","verticalOffset","checkOneWayPos","reversePoses","posOffset","boundInfo","boundIndex","boundInfos","info","nextDist","checkOneWayDist","directionIndex","directionPoses","reverseDirectionPoses","keepRatio","checkTwoWayDist","verticalDirection","horizontalDirection","verticalPos","horizontalPos","verticalBoundInfo","horizontalBoundInfo","isVeritcalDirectionBound","isHorizontalDirectionBound","checkSizeDist","snapDirection","isBoundRotate","relativePoses","boundRect","nextPos1","rotate","nextPos2","nextPos3","nextPos4","boundRotate","boundPos","r","checkSnapRotate","relativeLeft","relativeRight","relativeTop","relativeBottom","relativePos1","relativePos2","relativePos3","relativePos4","canBounds","relativeRad1","relativeRad2","checkSnapSize","checkSnapScale","sizeDist","snapOffset","dx","dy","getSnapInfosByDirection","alignPoses","startCheckSnapDrag","absolutePoses","checkSnapDrag","snapVerticalInfo","snapHorizontalInfo","snapInfos","middle","getSnapGuidelines","getElementGuidelineDist","elementPos","elementSize","targetSize","relativePos","Array","Object","minLeft","minTop","verticalSnapPoses","horizontalSnapPoses","verticalGuildelines","snap","verticalPosInfos","horizontalPosInfos","verticalBoundPos","horizontalBoundPos","elementVerticalGroup","elementHorizontalGroup","j","lineLeft","lineSize","toFixed","lineTop","dragEnd","dragControlCondition","rotatableDragControlCondtion","dragControlEnd","dragGroupStart","dragGroupEnd","dragGroupControlStart","dragGroupControlEnd","draggable","throttleDrag","throttleDragRotate","dragInfo","parentEvent","parentDragger","startTranslate","prevDist","prevBeforeDist","set","startRect","drag","dragRotateRad","deg","cos","sin","verticalInfo","horizontalInfo","adjustPoses","adjustPos","prevDistX","prevDistY","passDistX","passDistY","beforeTranslate","beforeDist","delta","beforeDelta","nextTransform","nextParams","dragGroup","setCustomDrag","move","client","isFlag","prevX","prevY","startX","startY","deltaX","deltaY","setRotateStartInfo","startAbsoluteOrigin","prevDeg","startDeg","loop","getDeg","moveableRect","startRotate","throttleRotate","prevLoop","absolutePrevDeg","absoluteDeg","getRotateInfo","getPositions","rotationPosition","rotatable","String","rotationRad","beforeInfo","afterInfo","rotatation","isRotate","dragControl","beforeRotate","dragGroupControlCondition","parentBeforeOrigin","eventParams","childClient","prevClient","Draggable","CustomDragger","dragGroupControl","dragResult","renderControls","defaultDirections","directions","directionMap","directionRotation","renderAllDirections","renderDiagonalDirections","resizable","throttleResize","renderDirections","inputTarget","startOffsetWidth","startOffsetHeight","startDirection","fixedOriginalPosition","startWidth","startHeight","setOrigin","isResize","parentScale","parentKeepRatio","distWidth","distHeight","standardRad","ratioRad","signSize","nextWidth","nextHeight","snapDist","isNoSnap","inverseDelta","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","originalX","originalY","scalable","throttleScale","startScale","isScale","nowDist","stateDirection","isArray","snapHeight","snapWidth","prevPos","getMiddleLinePos","dot","getTriangleRad","rad1","rad2","isValidPos","poses1","poses2","pi","warpable","linePosFrom1","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","warpTargetMatrix","targetInverseMatrix","ignoreDimension","startMatrix","posIndexes","isWarp","selectedPoses","nearByPoses","h","createWarpMatrix","multiplyCSS","AREA","AREA_PIECES","AREA_PIECE","AVOID","restoreStyle","removeClass","cssText","renderPieces","isDragArea","posX","posY","rects","children","call","nextElementSibling","addClass","isMoveableElement","containsTarget","contains","prevInputTarget","targetIndex","findIndex","parentTarget","getDefaultScrollPosition","scrollContainer","scrollable","scrollThreshold","dragScroll","DragScroll","on","offsetX","offsetY","scrollBy","checkScroll","getScrollPosition","threshold","ev","MOVEABLE_ABLES","Default","Snappable","Pinchable","Rotatable","Resizable","Scalable","Warpable","Scrollable","DragArea","Origin","defaultGroupRotate","refs","getMaxPos","getMinPos","getGroupRect","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","tan","a2_1","b1s_1","b2s_1","b1","b2","rotatePoses","changedWidth","ChildrenDiffer","isContainerChanged","added","changed","removed","updateGroup","clientRect","_super","Groupable","MoveableGroup","defaultProps","isArr","nextProps","moveableTarget","updateTarget","componentWillUnmount"],"mappings":"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"}